# 基础知识

## 以太网的由来

Ethernet（以太网）于 20 世纪 70 年代中期，由 Xerox 公司分部 Palo Alto 研究中心（PARC）开发的。Xerox 最早发明的是一个 2Mbps 的以太网,后来又和 Intel 和 DEC 合作开发了出了 10Mbps 的以太网,俗称(Ethernet II 或Ethernet DIX).后来IEEE 通过802 委员会(802 Committee)把Ethernet 标准化为IEEE 802.3。它和 Ethernet II 十分相似。

在TCP/IP 中，以太网的 IP 数据报文的封装格式由 RFC 894 定义，IEEE802.3 网络的IP 数据报文封装由 RFC 1042 定义。当今最常使用的封装格式是 RFC894 定义的格式，通常称为 Ethernet II 或者 Ethernet DIX。

## 以太网的数据链路层

在以太网中，针对不同的双工模式，提供不同的介质访问方法：

在半双工模式下采用的是 CSMA/CD 的访问方式。

而在全双工模式下则可以直接进行收发，不用预先判断链路的忙闲状态。

半双工和全双工是物理层的概念，而针对物理层的双工模式提供不同访问方式则是数据链路层的概念，这样就形成了以太网的一个重要特点：数据链路层和物理层是相关的。

由于以太网的物理层和数据链路层是相关的，针对物理层的不同工作模式，需要提供特定的数据链路层来访问。这给设计和应用带来了一些不便。

为此，一些组织和厂家提出把数据链路层再进行分层，分为逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。

## MAC 子层

- 提供物理链路的访问。
- 链路级的站点标识：在数据链路层识别网络上的各个站点。
- 也就是说，在该层次保留了一个站点地址，即 MAC 地址，来标识网络上的唯一一个站点。
- 链路级的数据传输：从 LLC 子层接收数据，附加上 MAC 地址和控制信息后把数据发送到物理链路上； 在这个过程中提供校验等功能。

## LLC 子层

而 IEEE802.3 帧中的 LLC 子层除了定义传统的链路层服务之外，还增加了一些其他有用的特性。这些特性都由 DSAP、SSAP 和 Control 字段提供。

例如以下三种类型的点到点传输服务：

- 无连接的数据包传输服务

  - 目前的以太网实现就是这种服务。

- 面向连接的可靠的数据传输服务

  - 预先建立连接再传输数据，数据在传输过程中可靠性得到保证。

- 无连接的带确认的数据传输服务。

  - 该类型的数据传输服务不需要建立连接，但它在数据的传输中增加了确认机制，使可靠性大大增加。




# 二层交换

## VLAN

### VLAN 基本概念


 ![image-20240517122520048](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517122520048.png)


 一个 VLAN 中所有设备都是在同一广播域内，不同的 VLAN 为不同的广播域

VLAN 之间互相隔离，广播不能跨越 VLAN 传播，因此不同 VLAN 之间的设备一般无法互访，不同 VLAN 间需通过三层设备实现相互通信

一个 VLAN 一般为一个逻辑子网，由被配置为此 VLAN 成员的设备组成

VLAN 中成员多基于交换机的端口分配，划分 VLAN 就是对交换机的接口划分

VLAN 工作于 OSI 参考模型的第二层

VLAN 是二层交换机的一个非常根本的工作机制

### VLAN 基本通信原理

为了提高处理效率，交换机内部的数据帧一律都带有 VLAN Tag，以统一方式处理。当一个数据帧进入交换机端口时，如果没有带 VLAN Tag，且该端口上配置了 PVID（Port VLAN ID），那么，该数据帧就会被标记上端口的 PVID。如果数据帧已经带有 VLAN Tag，那么，即使端口已经配置了 PVID，交换机不会再给数据帧标记 VLAN Tag。PVID 是“端口缺省 VLAN ID”的意思，即一个端口缺省属于的 VLAN。

由于端口类型不同，交换机对帧的处理过程也不同。下面根据不同的端口类型分别介绍。

#### Access 端口处理帧的过程

Access 端口处理 VLAN 帧的过程如下：

1. 收到一个二层帧。

2. 判断帧是否有 VLAN Tag。

   没有 Tag，则标记上 Access 端口的PVID，进行下一步处理。

   有 Tag，则比较帧的 VLAN Tag 和端口的 PVID，两者一致则进行下一步处理；否则丢弃帧。

3. 二层交换机根据帧的目的 MAC 地址和 VLAN ID 查找 VLAN 配置信息，决定从哪个端口把帧发送出去。

4. 交换机根据查到的出接口发送数据帧。

   当数据帧从 Access 端口发出时，交换机先剥离帧的 VLAN Tag，然后再发送出去。

   当数据帧从 Trunk 端口发出时，直接发送帧。

   当数据帧从 Hybrid 端口发出时，交换机判断 VLAN 在本端口的属性是 Untag 还是 Tag。如果是 Untag， 先剥离帧的 VLAN Tag，再发送；如果是 Tag，直接发送帧。

#### Trunk 端口处理帧的过程

Trunk 端口处理 VLAN 帧的过程如下：

1)    收到一个二层帧。

2)    判断帧是否有 VLAN Tag。

没有 Tag，则标记上 Trunk 端口的 PVID，进行下一步处理。

有 Tag，则判断该 Trunk 端口是否允许该 VLAN 帧进入。允许则进行下一步处理，否则丢弃帧。

3)    二层交换机根据帧的目的 MAC 地址和 VLAN ID，查找 VLAN 配置信息，决定从哪个端口把帧发送出去。

4)    交换机根据查到的出接口发送数据帧。

当数据帧从 Access 端口发出时，交换机先剥离帧的 VLAN Tag，然后再发送出去。

当数据帧从 Trunk 端口发出时，直接发送帧。

当数据帧从Hybrid 端口发出时，交换机判断VLAN 在本端口的属性是Untag 还是Tag。如果是Untag， 先剥离帧的 VLAN Tag，再发送;如果是 Tag，直接发送帧。

## TRUNK 

### Trunk 概述


![image-20240517123113271](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517123113271.png)


当一条链路，需要承载多 VLAN 信息的时候，需使用 trunk 来实现

Trunk 两端的交换机需采用相同的干道协议

一般见于交换机之间或交换机与路由器、服务器之间

### 封装协议

 ![img](file://C:/Users/Yan/Desktop/Security/%E8%AF%BE%E4%BB%B6/19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image011.gif?lastModify=1715918953)

### Dot1q

#### 帧格式

![image-20240517123911200](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517123911200.png)

**802.1Q Tag** **包含** **4** **个字段，其含义如下：**

####  EtherType

长度为 2 字节，表示帧类型。取值为 0x8100 时表示 802.1Q Tag 帧。如果不支持 802.1Q 的设备收到这样的帧，会将其丢弃。

#### PRI

Priority，长度为 3 比特，表示帧的优先级，取值范围为 0～7，值越大优先级越高。

用于当交换机阻塞时，优先发送优先级高的数据包。

#### CFI

Canonical Format Indicator，长度为 1 比特，表示 MAC 地址是否是经典格式。

CFI 为 0 说明是经典格式，

CFI 为 1 表示为非经典格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。

在以太网中，CFI 的值为 0。

#### VID

VLAN ID，长度为 12 比特，表示该帧所属的 VLAN。在 VRP 中，可配置的 VLAN ID 取值范围为 1～4094。

#### Native VLAN

在 802.1q 的 native vlan 是不打标签的，使用 Dot1q 的交换机把所有未被标记的 frame 转发到 native vlan 中， 而 ISL 会对所有的数据帧，包括 native vlan 进行封装，因此如果收到没有封装的数据帧它会丢弃。

Native VLAN 所属的帧在经过 trunk 时不打标签

Native VLAN 在 Trunk 两端必须匹配，否则会出现 VLAN 流量互串

默认的 native vlan 是 vlan 1

建议将一个生僻的 VLAN 配置为 Native vlan


 ![image-20240517134928823](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517134928823.png)


我们看上面这个图，两台交换机 trunk 两端 native vlan 不一样，会有什么问题？首先两端的 vlan2 通信肯定是没有问题的，但是 vlan3 和 vlan4 通信就有问题了，左边 vlan3 的用户发出来的数据帧从左交换机出去上 trunk，是不打标签的，但是这些数据帧到了右交换机，它会认为这些数据帧是属于 vlan4 的，这就出现问题了。

### Trunk 配置

```
Switch(config-if)# switchport mode access
```

将接口设置为 access 模式

```
Switch(config-if)# switchport mode encapsulation {dot1q | ISL}  
```

如果接口为 trunk，设置干道协议类型

```
Switch(config-if)# switchport mode dynamic {auto | desirable} 
```

将接口设置为 DTP 动态协商，可选 auto 或 desirable

```
Switch(config-if)# switchport nonegotiate
```

将接口设置为 nonegotiate，不发送 DTP 帧，如果配置为非协商，那么就必须手工配置接口模式，为 access

或 trunk

![image-20240517141142098](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517141142098.png)



# Spanning-tree（生成树）

## 协议概述

![image-20240517143738098](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517143738098.png)

如果接入层交换机单链路上联，则存在单链路故障另一个问题的单点故障，如果任意一个汇聚设备宕机，将直接导致下联的接入网络挂掉

与是接入层交换机采用双链路上联到两台汇聚设备，构成一个物理链路冗余的二层环境，解决了单链路故障问题

但是二层环境存在环路

生成树用于解决这个问题

通过生成树协议，在逻辑上将特定端口进行 Block，从而实现物理上存在冗余环境，而二层上又阻止环路的产生

当拓扑发生变更的时候，生成树协议能够探测到这些变化，并且及时自动的调整接口状态，从而适应网络拓扑的变化，实现链路冗余

## 协议基础

### 生成树协议

| PROTOCOL   |               |         | Describe                          |
| ---------- | ------------- | ------- | --------------------------------- |
| STP (PVST) | Public        | 802.1 D |                                   |
| PVST+      | Cisco Private |         | Portfast,uplinkfast, backbonefast |
| RSTP       | Public        | 802.1W  | 集成了 pvst 的功能并公有化        |
| MST        | Public        | 802.1S  |                                   |

### 参数

**网桥 ID （8 字节）= 网桥优先级(2 字节)+网桥 MAC (6 字节)**

缺省优先级 32768,范围 0-65535 （前 4bit 表示优先级,后 8bit 作为 system id,为协议扩展用，越小越好,4096 的倍数）

**端口 ID （2 字节）= 端口优先级(1 字节)+端口 ID(1 字节)**

缺省优先级 128，范围 0-255，越小越好

**根路径开销**


本交换机到达根交换机路径的总开销越小越好，与接口带宽有关

![image-20240517143959870](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517143959870.png)



## 802.1D

### BPDU 报文

BPDU 有两种类型：配置 BPDU 及 TCN

#### 配置 BPDU

在网络刚开始运行的阶段，所有交换机都会从所有端口发送 BPDU，大家都认为自己是 root，随着 BPDU 泛洪和收集，根据 BPDU 中所含信息，大家 PK 出来个结果，root 被选举出来了。在此之后由 Root 以默认 2S 为周期发送 BPDU，所有的非 root 交换机从自己的根端口收到 BPDU，再从自己的指定端口产生 bpdu 发出去。这就有点像我们从 root 倒一盆水下来，水顺着这颗无环的树从上往下不断的流。另外，被 block 的非指定端口会源源不断的收到链路上的 bpdu 并一直侦听，当其在一定时间内没有再收到 bpdu，则认为链路出现了故障，开始进入新的收敛阶段。

| 字节 | 字段                  | 描述                                                         |
| ---- | --------------------- | ------------------------------------------------------------ |
| 2    | 协议                  | 代表上层协议（BPDU），该值总为 0                             |
| 1    | 版本                  | （802.1D 的总为  0）                                         |
| 1    | TYPE                  | “配置  BPDU”为 0x00、“TCN BPDU”为  0x80                      |
| 1    | 标志                  | LSB 最低有效位表示  TC 标志；MSB 最高有效位表示 TCA 标志     |
| 8    | **根** **ID**         | 根网桥的桥 ID                                                |
| 4    | **路径开销**          | 到达根桥的 STP cost                                          |
| 8    | **网桥** **ID**       | BPDU 发送桥的  ID                                            |
| 2    | **端口** **ID**       | BPDU 发送网桥的端口 ID（优先级+端口号）                      |
| 2    | 消息寿命  Message age | 从根网桥发出 BPDU 之后的秒数（这个 BPDU 存活了多长时间了），每经过一个网桥都减 1，所以它本质上是到达根桥的跳数。 |
| 2    | 最大寿命  Max age     | 当一段时间未收到任何 BPDU，生存期到达 MAX age 时，网桥认为该端口连接的  链路发生故障。也可以理解为这个 BPDU 的最大寿命，默认 20S |
| 2    | HELLO 时间            | 根网桥连续发送的 BPDU 之间的时间间隔。默认 2S                |
| 2    | 转发延迟              | 在监听和学习状态所停留的时间间隔。默认 15S                   |



### STP 的运行

#### 解决环路

**STP 采用四部来解决二层环路：**

1)    在一个交换网络中选举一个 root bridge

2)    在每个非根桥上选举一个根端口

3)    为每个 Segment 选举一个指定端口

4)    阻塞非指定端口

#### 比较原则

STP 需要网络设备相互交换消息来检测桥接环路，该消息称为**网桥协议数据单元** **BPDU,** 阻塞端口也会不断收到 BPDU，以保证故障发生的时候，仍然可以计算出一棵新的 STP。要理解 STP 的工作过程，非常重要的一点是要理解 BPDU 中各字段的含义，因为这些都是 STP 赖以工作的根本。

**生成树构造一个无环路拓扑时，总是使用相同的 4 步来判定：**

1. 最低根桥 ID

2. 到根桥的最低路径成本

3. 最低的发送者网桥 ID

4. 最低的发送者端口 ID


网桥使用这 4 步来保存各个端口接收到的“最佳”的 BPDU 的一个副本。每个 BPDU 到达时，都会按照这个 4 步判决步骤来进行检查，看它是否该端口保存的 BPDU 更优，如果是，则会更新。

当一个网桥开始活动时， 他的每个端口都是每 2s 发送一个BPDU，而当一个端口收到一个比现在发送的更优的 BPDU，则本地端口会停止发送，如果在一段时间内 （却省为 20s）后他不再收到来自邻居的更优BPDU，则他将再次发送。因此对于 802.1D 来说，根桥会不停的向所有接口发送 BPDU，而非根桥会从自己的根端口收到 BPDU，并且向自己的指定端口去发 BPDU，非指定端口是不会发送 BPDU 的，只会侦听。

#### 注意事项：

根桥的角色是可抢占的

桥 ID 中的 MAC，是交换机的背板 MAC，端口 ID 中的 MAC 是交换机的端口 MAC，查看交换机上的所有 mac 可用

```
show interface | include bia
```

二层交换机的端口 mac 就在这用了

### 案例分析

CASE1：

 ![image-20240517150814434](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517150814434.png)

首先选 root，交换机 MAC 最小的 SW1 胜出，成为 root

其次在非根桥 SW2 及 SW3 上选择一个 root port，如图所示，因为这些端口到达 SW1 开销最小

最后在每个 segment 上选择一个指定端口 DP，sw1 是根桥，所有接口都是 DP，最后比较 SW2、SW3 之间直连链路的两个接口。SW2 会从接口上收到 SW3 发来的 BPDU，SW3 也会收到 SW2 发来的 BPDU 各自比较自己和收到 BPDU 中的桥 ID（也就是所谓的比较发送桥 ID），最终 SW2 由于 MAC 地址较小胜出。因此 Block 掉 SW3 的那个接口。

CASE2：

![image-20240517150913780](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517150913780.png)





根桥的选举就不说了，接下去看 RP，SW2 两个接口，都会收到 BPDU，而上联到 root 的接口收到的 BPDU 中到 root 的开销最小，所以上联口为 RP。 SW3 却不一样，由于连接到 root 的接口带宽仅为 10M，因此连接 SW2 的接口胜出为 RP。最后选择 DP。简单不赘述了。

CASE3：

![image-20240517150954001](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517150954001.png)

根桥的选举就不说了

根端口的选举，SW2 和 SW3 都比较简单。关键看 SW4，有两个接口，这两个接口都会收到 BPDU，首先看到 root 的开销，由于这两个 BPDU 的到 root 开销相等，加上 SW4 这两个接口的带宽也相等，因此这一步比较不出来，接着看发送者桥 ID，也就是收到的这两份 BPDU 的 BridgeID，比较后发现 SW2 的 MAC 更小（比SW3 小），因此 SW4 上连接 SW2 的接口胜出，成为 RP。

最后看 DP，也比较简单如图所示。我们拿 SW3 及 SW4 之间的 segment 举例，由于 SW3 及 SW4 都会产生BPDU，而 SW3 发给 SW4 的 BPDU 明显要优于 SW4 自己产生的从这个接口发送的 BPDU，因此最终 SW4 的接口胜出。

CASE4：



 

![img](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image065.jpg)

 

根桥的选举就不说了。

接下去看 RP，SW2 有两个接口，这两个接口都会收到 BPDU，都来自 SW1，因此这两个 BPDU 首先到 root 的开销都是 0，相等；其次发送者的桥 ID，由于是来自同一台交换机，因此也相等，也比较不出来；再比较这两个 BPDU 的端口 ID，也就是 SW1 上这两个接口的端口 ID，我们假设两个接口优先级相等，那么就比这两端口的接口 ID，最终选出 SW2 上的根端口 F0/1。

注意，这时候如果试图在 SW2 上将 F0/2 的接口优先级改小，也是没用的，因为看的是发送者的端口 ID。所以如果在 SW1 上，将 F0/2 的端口优先级调小。那么 SW2 上，F0/2 就会胜出成为根端口。

 

### STP 端口状态

 

#### 1. 写在前面的话：

由于网络设备存在固有的滞后，所以交换网络中也就存在传播延迟。基于上述原因，拓扑变更就可能发生在交换网络中的不同时间和不同的网段。如果 2 层接口直接从生成树的 block 状态切换到转发状态，就可能会出现暂时的数据环路。为了缓解这种问题，在开始转发数据帧之前，端口应当等待新的拓扑信息传播到整个交换网络中。

#### 2. 计时器

阻塞到转发状态通常要 30-50s（默认 50S，即 20+15+15），这个时间也可以通过配置生成树计时器来调整。

**Hello** **时间**      根网桥发送配置 BPDU 的时间间隔     缺省为２s

**转发延迟时间**    侦听到学习状态， 或者学习状态转换到转发状态所需要的时间              缺省为 15s。

**最大存活期**     在丢弃 BPDU 之前，网桥用来存储 BPDU 的时间，缺省为 20s。如果连续收不到 10 个 bpdu

（20s 的时间），开始进入 listening 状态

#### 3. STP 各状态如下：

 ![image-20240517151135228](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517151135228.png)

#### 4. STP 端口状态转换过程 

![image-20240517151149626](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517151149626.png)

 

 

 

### STP 拓扑变更

#### TCN BPDU 概述

当网络拓扑出现变更的时候，最先意识到变化的交换机将发送TCN BPDU。在发生以下时间时，交换机发送TCN：

对于处于转发和监听状态的接口，过渡到 Block 状态（链路故障的情况）

端口进入转发状态，并且网桥已经拥有指定端口

非 root 网桥在它的指定端口收到 TCN

#### 拓扑变更过程

最先意识到拓扑变更的交换机发送TCN，指定网桥接收TCN 并且通过立即回送一个TCA 被置位的正常BPDU

来确认，在该网桥确认这个 TCN 之前，负责通知拓扑变更的网桥将持续发送 TCN BPDU。接下去该指定网桥将为自己的根端口产生另外的 TCN，并且这个过程一路发到 root 为止。

一旦网桥意识到网络中发生拓扑变更的情况，它将发送 TC 被置位的配置 BPDU，网络中的每台交换机都将传递这些被置位的 BPDU，进而便于每个单独的网桥都意识到拓扑变更的情况。

#### 拓扑变更过程范例

![img](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image074.jpg)

1) SwitchA 挂掉

2) SwitchB 最先检测到拓扑变化，于是产生 TCN BPDU 并从根端口发送出去（因为根端口是朝着根桥的方向），B 将连续发送 TCN BPDU 直到指定交换机 C 发送 TCN ACK 进行确认

3) SwitchB 收到这个TCN BPDU，回送一个 TCN ACK 进行确认，同时向自己的根端口转发这个 TCN BPDU

4) Root 收到这个 TCN，回送一个 TCN ACK 给 C。

5) Root 修改自己的配置 BPDU，以此来通告整个交换网络关于拓扑变更的情况。 Root 在配置 BPDU 中设置一段时间的拓扑变更（TC 标志），这段时间等于转发延迟+Max. Age，默认 35S

6) 当交换机收到 Root 发出的这个 TC 标志置位的配置 BPDU，它们使用转发延迟计时器（默认 15S）来更新其 MAC 地址表中的条目。也就是说条目的寿命由原来的 300S 的默认值变成 15S，这样能保证 MAC 地址条目更快速的刷新。交换机将持续这个过程，直到不再从 Root 收到 TC BPDU 消息为止。

注意事项：我们会发现当拓扑变更的时候，就会产生 TCN，然而有些情况下 TCN 的过渡泛洪可能会对网络才成不必要的影响，通过在接入层交换机上、连接 PC 终端设备的接口设置为 portfast 可以在一定程度上优化网络，防止由于 PC 的开关机导致的接入交换机端口 updown 而产生过多的 TCN。

# 三层交换

## CAM 及TCAM

### CAM 表

**CAM** **是交换机用于二层交换时所查的表**

a)    Content Addressable Memory Table 内容可寻址内存

b)    在查表时，使用二进制的 0、1 位进行匹配，并且需严格匹配，也就是目的 MAC 与 CAM 表中的 MAC 需完全匹配

c)     查找的结果如果发现完全匹配项，则根据返回的端口号将数据转发出去

 ![image-20240517152505069](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517152505069.png)

 



#### TCAM 表

**TCAM** **是路由模块或路由器用于三层转发时所查的表**

a)    匹配表项中的 0、1、x（x 为无所谓）

b)    最长匹配原则




## VLAN 间路由

### 单臂路由

![image-20240517152842374](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517152842374.png)



我们知道，在二层交换环境下，一个 VLAN 就是一个广播域，不同 VLAN 不同的广播域，一般也是不同的逻辑子网，而且相互隔离，互相是无法互访的，这样能起到隔绝广播的作用。但是实际网络中往往 VLAN 有互访的需求， 例如同一公司不同的部门划分在不同的 VLAN，那么如果这些部门之间有数据往来的需求呢？那么二层交换机就无法实现了，需要借助三层设备。一个最简单的方法，就是使用路由器，用单臂路由的解决方案：

 ![image-20240517152900970](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517152900970.png)

所谓单臂路由，就是在路由器的以太网口上（必须是 100M 接口以上），来承载 VLAN 流量，让路由器和交换机跑一个 Trunk，使用 dot1Q 的封装，这时候，为了让路由器的以太网口支持 Dot1Q 及识别并承载 VLAN 流量，那么需对物理接口进行子接口的划分，如上图。

将 Fa0/0 接口划分成两个子接口，并且配置封装协议 Dot1Q，同时为流量分别打上 VLAN 的 tag，这样一来，交换机和路由器之间就起了一个 trunk。路由器的这两个子接口分别配置两个 VLAN 的网关 IP，作为 VLAN 用户的网关。

配置方式如下：



![img](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image144.jpg)

使用单臂路由确实能解决 VLAN 间数据互访的问题，但是却也存在种种弊端，例如路由器的接口，负载太大，流量需二次进出接口或链路，导致干道链路负载也过重，而且扩展性特别差。

### 路由 VS. 交换的园区网架构

![image-20240517152936242](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517152936242.png)

在过去，交换是基于硬件的转发，而路由是基于软件的转发，因此园区网络更多的采用交换网络的设计。而如今，路由已经几乎与交换一样快，也能够基于硬件做转发，与此同时路由的设计很好的解决了交换网络的二层环路问题，以及 LAN 的隔离问题

### Switch Virtual Interfaces（SVI）



 

![img](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image148.jpg)

 

OK，在理解了单臂路由之后，我们再来看看三层交换机是如何实现 VLAN 间的数据互访的，我们从这里为切入点，开始理解并部署三层交换。我们知道二层交换机是可以实现二层交换的，它看的是数据帧，对帧头的二层信息进行读取并且根据自己的 CAM 表进行转发。而三层交换机相当于在二层交换机的基础上，多了个路由模块， 于是乎它就能支持路由功能了：支持路由选择协议、支持三层数据的转发、支持 IP 路由查找、支持三层接口等等。

先来认识一下第一种三层接口：SVI 交换式虚接口，SVI 的一个逻辑接口，也就是说不是一个物理接口，当我们在交换机上创建了一个 VLAN 之后，紧接着就可以创建一个与这个 VLAN 对应的 SVI 接口，例如我们创建了VLAN10，那么 VLAN10 对应的 SVI 接口就是 interface vlan10 或者叫 SVI10，这个 SVI10 是一个三层接口，你可以为这个 SVI 口配置 IP 地址，与 VLAN10 内的 PC 用户的 IP 地址同一网段，那么这样一来，VLAN10 内的用户就能够将网关指向这个 SVI 接口，当 VLAN10 的 PC 需要访问本网段以外的网络时他们将数据交给网关，也就是 SVI10，再由 SVI 去做路由查找及数据转发。实际上，在这个理解过程中，我们可以拿单臂路由那个模型对类比。

所以看上面这图，在三层交换机上创建了两个 VLAN：10 和 20，同时为两个 VLAN 的 SVI 分配了地址作为各自 VLAN 的用户网关，这样一来，这台交换机的路由表里就有了两个 VLAN 网段的路由。那么当两 VLAN 之间要互访时，VLAN10 的用户将数据丢给自己的网关，也就是 VLAN10 的 SVI，数据到了 SVI10 之后，三层交换机查表，发现目的地是 VLAN20 的所在网段，因此将数据从 VLAN20 扔出去，最终抵达目的地的 VLAN20 的 PC。

### 三层交换机的各类端口



 

![img](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image149.gif)

 

总的来说，三层交换机包含两类端口：二层接口 L2 和 三层接口 L3

二层接口(switchport)：access 模式、trunk 模式

三层接口：路由接口、SVI 接口

其中二层接口包含我们非常熟悉的 access mode 和 trunk mode。交换机的所有物理接口默认是二层接口，也就是 switchport。

三层接口有两种，一种是 SVI 上面我们已经讨论过了，另一种是 routed port，或者叫 no switchport。注意 SVI 口是一个虚拟接口，而 routed port 是物理接口。三层交换机支持将物理接口变成一个类似路由器物理接口的三层接口，具体的配置就是进入特定接口的配置模式后，使用 no switchport 命令，该接口就变成了一个 L3 的路由口， 你可以给他配置 IP，就像操作路由器的一个以太网口哪样来操作它。

正是由于三层交换机支持这么多种类型的接口，使得三层交换网络的部署更加的灵活和可扩展。

下面我们来看一个三层交换部署的简单案例：

案例一：

![image-20240517153423174](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517153423174.png)



案例二：

![image-20240517153447568](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/image-20240517153447568.png)



## 网关冗余技术

 VRRP



 

 

# 交换网络安全

## Port-Security

### Port-Security 概述



 

![img](19.%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/clip_image197.jpg)

 

在部署园区网的时候，对于交换机，我们往往有如下几种特殊的需求：

限制交换机每个端口下接入主机的数量（MAC 地址数量）

限定交换机端口下所连接的主机（根据 IP 或 MAC 地址进行过滤）

当出现违例时间的时候能够检测到，并可采取惩罚措施

### 理解 Port-Security

**Port-Security 安全地址：secure MAC address**

- 在接口上激活 Port-Security 后，该接口就具有了一定的安全功能，例如能够限制接口（所连接的）的最大 MAC 数量，从而限制接入的主机用户；或者限定接口所连接的特定 MAC，从而实现接入用户的限制。那么要执行过滤或者限制动作，就需要有依据，这个依据就是**安全地址** – secure MAC address。

- 安全地址表项可以通过让使用端口动态学习到的 MAC（SecureDynamic），或者是手工在接口下进行配置（SecureConfigured），以及 sticy MAC address（SecureSticky） 三种方式进行配置。

- 当我们将接口允许的MAC 地址数量设置为1 并且为接口设置一个安全地址，那么这个接口将只为该MAC

- 所属的 PC 服务，也就是源为该 MAC 的数据帧能够进入该接口。

**当以下情况发生时，激活惩罚（violation）：**

- 当一个激活了 Port-Security 的接口上，MAC 地址数量已经达到了配置的最大安全地址数量，并且又收到了一个新的数据帧，而这个数据帧的源 MAC 并不在这些安全地址中，那么启动惩罚措施

- 当在一个 Port-Security 接口上配置了某个安全地址，而这个安全地址的 MAC 又企图在同 VLAN 的另一个 Port-Security 接口上接入时，启动惩罚措施

- 
  当设置了 Port-Security 接口的最大允许 MAC 的数量后，接口关联的安全地址表项可以通过如下方式获取：

  - 在接口下使用 switchport port-security mac-address 来配置静态安全地址表项
  - 使用接口动态学习到的 MAC 来构成安全地址表项
  - 一部分静态配置，一部分动态学习

**Port-Security 与 Sticky MAC 地址**

通过接口动态学习的 MAC 地址构成的安全地址表项，在接口出现 up/down 后，将会丢失这些通过动态学习到的 MAC 构成的安全地址表项，但是所有的接口都用 switchport port-security mac-address 手工来配置，工作量又太大。因此这个 sticky mac 地址，可以让我们将这些动态学习到的 MAC 变成“粘滞状态”，可以简单的理解为，我先动态的学，学到之后我再将你粘起来，形成一条”静态“ （实际上是SecureSticky）的表项。

在 up/down 现象出现后仍能保存。而在使用 wr 后，这些 sticky 安全地址将被写入 start-up config，即使设备重启也不会被丢失。